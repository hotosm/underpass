//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <filesystem>
#include <iostream>
#include <regex>
#include <string>
#include <utility>
#include <vector>
// #include <pqxx/pqxx>
#include <cctype>
#include <cmath>
#include <fstream>
#include <sstream>
// #include <iterator>
#ifdef LIBXML
#include <libxml++/libxml++.h>
#endif
#include <gumbo.h>

#include <osmium/builder/osm_object_builder.hpp>
#include <osmium/handler.hpp>
#include <osmium/io/any_input.hpp>
#include <osmium/io/any_output.hpp>
#include <osmium/visitor.hpp>

#include "boost/date_time/local_time/local_time.hpp"
#include "boost/date_time/posix_time/posix_time.hpp"
#include <boost/date_time.hpp>
#include <boost/format.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;
//#include <boost/tokenizer.hpp>
#include <boost/asio/connect.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/error.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/http/parser.hpp>
#include <boost/beast/version.hpp>
#include <boost/filesystem.hpp>
#include <boost/iostreams/device/array.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/filtering_streambuf.hpp>

namespace beast = boost::beast;   // from <boost/beast.hpp>
namespace net = boost::asio;      // from <boost/asio.hpp>
namespace ssl = boost::asio::ssl; // from <boost/asio/ssl.hpp>
namespace http = beast::http;     // from <boost/beast/http.hpp>
using tcp = net::ip::tcp;         // from <boost/asio/ip/tcp.hpp>

#include "data/underpass.hh"
#include "osmstats/changeset.hh"
#include "osmstats/replication.hh"
using namespace underpass;

/// Control access to the database connection
std::mutex db_mutex;

#include "log.hh"
using namespace logger;

namespace replication {

/// Parse the two state files for a replication file, from
/// disk or memory.

/// There are two types of state files with of course different
/// formats for the same basic data. The simplest one is for
/// a changeset file. which looks like this:
///
/// \-\-\-
/// last_run: 2020-10-08 22:30:01.737719000 +00:00
/// sequence: 4139992
///
/// The other format is used for minutely change files, and
/// has more fields. For now, only the timestamp and sequence
/// number is stored. It looks like this:
///
/// \#Fri Oct 09 10:03:04 UTC 2020
/// sequenceNumber=4230996
/// txnMaxQueried=3083073477
/// txnActiveList=
/// txnReadyList=
/// txnMax=3083073477
/// timestamp=2020-10-09T10\:03\:02Z
///
/// State files are used to know where to start downloading files
StateFile::StateFile(const std::string &file, bool memory)
{
    std::string line;
    std::ifstream state;
    std::stringstream ss;

    // It's a disk file, so read it in.
    if (!memory) {
        try {
            state.open(file, std::ifstream::in);
        } catch (std::exception &e) {
            log_debug(_("ERROR opening %1% %2%"), file, e.what());
            // return false;
        }
        // For a disk file, none of the state files appears to be larger than
        // 70 bytes, so read the whole thing into memory without
        // any iostream buffering.
        std::filesystem::path path = file;
        int size = std::filesystem::file_size(path);
        char *buffer = new char[size];
        state.read(buffer, size);
        ss << buffer;
        // FIXME: We do it this way to save lots of extra buffering
        // ss.rdbuf()->pubsetbuf(&buffer[0], size);
    } else {
        // It's in memory
        ss << file;
    }

    // Get the first line
    std::getline(ss, line, '\n');

    // This is a changeset state.txt file
    if (line == "---") {
        // Second line is the last_run timestamp
        std::getline(ss, line, '\n');
        // The timestamp is the second field
        std::size_t pos = line.find(" ");
        // 2020-10-08 22:30:01.737719000 +00:00
        timestamp = time_from_string(line.substr(pos + 1));

        // Third and last line is the sequence number
        std::getline(ss, line, '\n');
        pos = line.find(" ");
        // The sequence is the second field
        sequence = std::stol(line.substr(pos + 1));
        // This is a change file state.txt file
    } else {
        for (std::string line; std::getline(ss, line, '\n');) {
            std::size_t pos = line.find("=");

            // Not a key=value line. So we skip it.
            if (pos == std::string::npos) {
                continue;
            }

            const std::string key = line.substr(0, pos);
            const std::string value = line.substr(pos + 1);

            const std::vector<std::string> skipKeys{
                "txnMaxQueried", "txnActiveList", "txnReadyList", "txnMax"};
            if (key == "sequenceNumber") {
                sequence = std::stol(value);
            } else if (std::count(skipKeys.begin(), skipKeys.end(), key)) {
            } else if (key == "timestamp") {
                pos = value.find('\\', pos + 1);
                std::string tstamp =
                    value.substr(0, pos);           // get the date and the hour
                tstamp += value.substr(pos + 1, 3); // get minutes
                pos = value.find('\\', pos + 1);
                tstamp += value.substr(pos + 1, 3); // get seconds
                timestamp = from_iso_extended_string(tstamp);
            } else {
                log_error(_("Invalid Key found: "), key);
            }
        }
    }

    state.close();
}

// Dump internal data to the terminal, used only for debugging
void
StateFile::dump(void)
{
    std::cerr << "Dumping state.txt file" << std::endl;
    std::cerr << "\tTimestamp: " << timestamp << std::endl;
    std::cerr << "\tSequence: " << sequence << std::endl;
    std::cerr << "\tPath: " << path << std::endl;
    std::cerr << "\tcreated_at: " << created_at << std::endl;
    std::cerr << "\tclosed_at: " << closed_at << std::endl;
}

bool
StateFile::isValid() const
{
    return timestamp != boost::posix_time::not_a_date_time &&
           sequence >=
               (frequency == Underpass::freq_to_string(frequency_t::changeset)
                    ? 0
                    : 1) &&
           !path.empty() && !frequency.empty();
}

// parse a replication file containing changesets
bool
Replication::readChanges(const std::string &file)
{
    changeset::ChangeSetFile changeset;
    std::ifstream stream;
    stream.open(file, std::ifstream::in);
    changeset.readXML(stream);

    return true;
}

// Add this replication data to the changeset database
bool
Replication::mergeToDB()
{
    return false;
}

std::shared_ptr<std::vector<std::string>> &
Planet::getLinks(GumboNode *node,
                 std::shared_ptr<std::vector<std::string>> &links)
{
    // if (node->type == GUMBO_NODE_TEXT) {
    //     std::string val = std::string(node->v.text.text);
    //     log_debug(_("FIXME: " << "GUMBO_NODE_TEXT " << val);
    // }

    if (node->type == GUMBO_NODE_ELEMENT) {
        GumboAttribute *href;
        if (node->v.element.tag == GUMBO_TAG_A &&
            (href = gumbo_get_attribute(&node->v.element.attributes, "href"))) {
            // All the directories are a 3 digit number, and all the files
            // start with a 3 digit number
            if (href->value[0] >= 48 && href->value[0] <= 57) {
                //if (std::isalnum(href->value[0]) && std::isalnum(href->value[1])) {
                // log_debug(_("FIXME: %1%"), href->value);
                if (std::strlen(href->value) > 0) {
                    links->push_back(href->value);
                }
            }
        }
        GumboVector *children = &node->v.element.children;
        for (unsigned int i = 0; i < children->length; ++i) {
            getLinks(static_cast<GumboNode *>(children->data[i]), links);
        }
    }

    return links;
}

// Download a file from planet
std::shared_ptr<std::vector<unsigned char>>
Planet::downloadFile(const std::string &url)
{

    auto data = std::make_shared<std::vector<unsigned char>>();

    // The io_context is required for all I/O
    boost::asio::io_context ioc;

    // The SSL context is required, and holds certificates
    ssl::context ctx{ssl::context::sslv23_client};

    // Verify the remote server's certificate
    ctx.set_verify_mode(ssl::verify_none);

    // These objects perform our I/O
    tcp::resolver resolver{ioc};
    ssl::stream<tcp::socket> stream{ioc, ctx};

    // Look up the domain name
    auto const results = resolver.resolve(remote.domain, std::to_string(port));

    try {
        // Make the connection on the IP address we get from a lookup
        boost::asio::connect(stream.next_layer(), results.begin(), results.end());
        // Perform the SSL handshake
        stream.handshake(ssl::stream_base::client);
    } catch (boost::system::system_error ex) {
        log_error(_("stream write failed: %1%"), ex.what());
        return data;
    }

    // Set up an HTTP GET request message
    http::request<http::string_body> req{http::verb::get, url, version};

    req.keep_alive();

    // We want the host only: strip the rest
    static const std::regex re(R"raw(^(?:https?://)?([^/]+).*)raw");
    std::string host{remote.domain};
    host = std::regex_replace(host, re, "$1");

    req.set(http::field::host, host);
    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);
    // Send the HTTP request to the remote host
    try {
        http::write(stream, req);
        log_debug(_("Downloading %1% ... "), url);
    } catch (boost::system::system_error ex) {
        log_error(_("stream write failed: %1%"), ex.what());
        return data;
    }

    // This buffer is used for reading and must be persistant
    boost::beast::flat_buffer buffer;

    // Receive the HTTP response
    http::response_parser<http::string_body> parser;

    try {
        read(stream, buffer, parser);

        if (parser.get().result() == boost::beast::http::status::not_found) {
            log_error(_("Remote file not found: %1%"), url);
        } else {
            // Check the magic number of the file
            const auto is_gzipped{parser.get().body()[0] == 0x1f};
            if (is_gzipped) {
                log_debug(_("Downloaded body is gzipped"));
            } else {
                if (parser.get().body()[0] == '<') {
                    log_debug(_("Downloaded body is XML/HTML"));
                }
            }

            for (auto body = std::begin(parser.get().body());
                 body != std::end(parser.get().body()); ++body) {
                data->push_back(static_cast<unsigned char>(*body));
            }

            // Add the last newline back if not gzipped (or we'll get decompression error: unexpected end of file)
            if (!is_gzipped) {
                data->push_back('\n');
            }
        }

    } catch (boost::system::system_error ex) {
        log_error(_("stream read failed: %1%"), ex.what());
    }

    // Gracefully close the stream
    beast::error_code ec;
    stream.shutdown(ec);
    if (ec == net::error::eof) {
        // Rationale:
        // http://stackoverflow.com/questions/25587403/boost-asio-ssl-async-shutdown-always-finishes-with-an-error
        ec = {};
    }

    if (ec) {
        // Note: not sure about this, it looks harmless
        // log_debug(_("stream shutdown failed: %1%"), ec.message());
    }

    return data;
}

Planet::~Planet(void)
{
    ioc.reset(); // reset the I/O conhtext
    // stream.shutdown();          // shutdown the socket used by the stream
}

Planet::Planet(void){
    // FIXME: for bulk downloads, we might want to strip across
    // all the mirrors. The support minutely diffs
    // pserver = "https://download.openstreetmap.fr";
    // pserver = "https://planet.maps.mail.ru";
    // pserver = "https://planet.openstreetmap.org";
    // connectServer();
};

// Dump internal data to the terminal, used only for debugging
void
Planet::dump(void)
{
    log_debug(_("Dumping Planet data"));
    for (auto it = std::begin(changeset); it != std::end(changeset); ++it) {
        std::cerr << "Changeset at: " << it->first << it->second << std::endl;
    }
    for (auto it = std::begin(minute); it != std::end(minute); ++it) {
        std::cerr << "Minutely at: " << it->first << ": " << it->second
                  << std::endl;
    }
    for (auto it = std::begin(hour); it != std::end(hour); ++it) {
        std::cerr << "Minutely at: " << it->first << ": " << it->second
                  << std::endl;
    }
    for (auto it = std::begin(day); it != std::end(day); ++it) {
        std::cerr << "Daily at: " << it->first << ": " << it->second
                  << std::endl;
    }
}

bool
Planet::connectServer(const std::string &planet)
{

    // Gracefully close the socket
    boost::system::error_code ec;
    ioc.reset();
    ctx.set_verify_mode(ssl::verify_none);
    // Strip off the https part
    std::string tmp;
    auto pos = planet.find(":");
    if (pos != std::string::npos) {
        tmp = planet.substr(pos + 3);
    } else {
        tmp = planet;
    }

    if (!tmp.empty()) {
        remote.domain = tmp;
    }

    auto const results = resolver.resolve(tmp, std::to_string(port));
    boost::asio::connect(stream.next_layer(), results.begin(), results.end(),
                         ec);
    if (ec) {
        log_error(_("stream connect failed %1%"), ec.message());
        return false;
    }
    stream.handshake(ssl::stream_base::client, ec);
    if (ec) {
        log_error(_("stream handshake failed %1%"), ec.message());
        return false;
    }

    return true;
}

// Scan remote directory from planet
std::shared_ptr<std::vector<std::string>>
Planet::scanDirectory(const std::string &dir)
{
    log_debug(_("Scanning remote Directory: %1%"), dir);

    // The io_context is required for all I/O
    boost::asio::io_context ioc;

    // The SSL context is required, and holds certificates
    ssl::context ctx{ssl::context::sslv23_client};

    // Verify the remote server's certificate
    ctx.set_verify_mode(ssl::verify_none);

    // These objects perform our I/O
    tcp::resolver resolver{ioc};
    ssl::stream<tcp::socket> stream{ioc, ctx};

    // Look up the domain name
    auto const results = resolver.resolve(remote.domain, std::to_string(port));

    // Make the connection on the IP address we get from a lookup
    boost::asio::connect(stream.next_layer(), results.begin(), results.end());

    // Perform the SSL handshake
    stream.handshake(ssl::stream_base::client);

    auto links = std::make_shared<std::vector<std::string>>();

    // Set up an HTTP GET request message
    http::request<http::string_body> req{http::verb::get, dir, version};
    req.set(http::field::host, remote.domain);
    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);

    // Send the HTTP request to the remote host
    http::write(stream, req);

    // This buffer is used for reading and must be persistant
    boost::beast::flat_buffer buffer;

    // Receive the HTTP response
    http::response_parser<http::string_body> parser;
    // read_header(stream, buffer, parser);
    http::read(stream, buffer, parser);
    if (parser.get().result() == boost::beast::http::status::not_found) {
        return links;
    }
    GumboOutput *output = gumbo_parse(parser.get().body().c_str());
    getLinks(output->root, links);
    gumbo_destroy_output(&kGumboDefaultOptions, output);

    // Gracefully close the stream
    boost::beast::error_code ec;
    stream.shutdown(ec);
    if (ec == net::error::eof) {
        // Rationale:
        // http://stackoverflow.com/questions/25587403/boost-asio-ssl-async-shutdown-always-finishes-with-an-error
        ec = {};
    }
    if (ec) {
        log_debug(_("stream shutdown failed: %1%"), ec.message());
    }
    return links;
}

std::shared_ptr<replication::StateFile>
Planet::fetchData(frequency_t freq, const std::string &path,
                  const std::string &underpass_dburl)
{
    std::shared_ptr<StateFile> state = std::make_shared<StateFile>();
    // First search in the cache
    bool use_cache{!underpass_dburl.empty()};
    Underpass underpass;
    if (use_cache) {
        if (!underpass.connect(underpass_dburl)) {
            log_error(_("Could not connect to underpass DB, caching disabled! "
                        "- DB URL: %1%"),
                      underpass_dburl);
            use_cache = false;
        } else {
            RemoteURL url;
            try {
                url.parse("https://" + remote.domain + "/replication/" +
                          Underpass::freq_to_string(freq) + path);
                const long sequence{url.major * 1000000 + url.minor * 1000 +
                                    url.index};
                state = underpass.getState(freq, sequence);
            } catch (const std::exception &ex) {
                // Ignore...
            }
        }
    }

    if (!state->isValid()) {
        const auto full_path{"/replication/" + Underpass::freq_to_string(freq) +
                             path + ".state.txt"};
        auto data = downloadFile(full_path);
        if (data->size() == 0) {
            // There is a chance that for old changeset files we have no state!
            if (freq == frequency_t::changeset) {
                const auto osm_gz_full_path{"/replication/" +
                                            Underpass::freq_to_string(freq) +
                                            path + ".osm.gz"};
                data = downloadFile(osm_gz_full_path);
                if (data->size() == 0) {
                    log_error(_("StateFile (osm.gz) not found: %1%"),
                              osm_gz_full_path);
                } else {
                    // Extract timestamp from osm.gz
                    try {
                        boost::iostreams::filtering_streambuf<
                            boost::iostreams::input>
                            inbuf;
                        inbuf.push(boost::iostreams::gzip_decompressor());
                        boost::iostreams::array_source arrs{
                            reinterpret_cast<char const *>(data->data()),
                            data->size()};
                        inbuf.push(arrs);
                        std::istream instream(&inbuf);
                        try {
                            changeset::ChangeSetFile changeset;
                            changeset.readXML(instream);
                            if (changeset.changes.size() > 0) {
                                const auto timestamp{
                                    changeset.changes.back()->closed_at};
                                if (timestamp != not_a_date_time) {
                                    RemoteURL url;
                                    try {
                                        url.parse("https://" + remote.domain +
                                                  osm_gz_full_path);
                                        state->frequency =
                                            Underpass::freq_to_string(freq);
                                        state->sequence = url.sequence();
                                        state->path = path;
                                        state->timestamp = timestamp;
                                        state->closed_at = timestamp;
                                        state->created_at =
                                            changeset.changes.front()
                                                ->created_at;
                                    } catch (const std::exception &ex) {
                                        log_error(
                                            _("Couldn't get sequence from: %1%"),
                                            osm_gz_full_path);
                                    }
                                } else {
                                    log_error(
                                        _("Couldn't get timestamp from: %1%"),
                                        osm_gz_full_path);
                                }
                            } else {
                                log_error(_("Couldn't parse empty: %1%"),
                                          osm_gz_full_path);
                            }
                        } catch (std::exception &e) {
                            log_error(_("Couldn't parse: %1% %2%"),
                                      osm_gz_full_path, e.what());
                        }
                    } catch (std::exception &e) {
                        log_error(_("%1% is corrupted!"), remote.url);
                    }
                    log_debug(_("Timestamp extracted from osm.gz for path %1%"),
                              path);
                }
            } else {
                log_error(_("StateFile not found: %1%"), full_path);
            }
        } else {
            const std::string tmp(data->begin(), data->end());
            auto state_candidate =
                std::make_shared<replication::StateFile>(tmp, true);
            state_candidate->path = path;
            state_candidate->frequency = Underpass::freq_to_string(freq);
            if (state_candidate->isValid()) {
                state = state_candidate;
                if (use_cache) {
                    if (!underpass.writeState(*state.get())) {
                        log_error(_(
                            "Could not store cached state in the underpass DB!"));
                    }
                }
            } else {
                log_error(_("Invalid state fetched from path: %1%"), path);
            }
        }
    }
    return state;
}

std::string
Planet::sequenceToPath(long sequence)
{
    return str(format("/%03d/%03d/%03d") % (sequence / 1000000) %
               (sequence / 1000 % 1000) % (sequence % 1000));
}

std::shared_ptr<StateFile>
Planet::fetchDataLast(frequency_t freq, const std::string &underpass_dburl)
{
    const bool is_changeset{freq == frequency_t::changeset};
    const auto url{str(format("https://%1%/replication/%2%/state.%3%") %
                       remote.domain % Underpass::freq_to_string(freq) %
                       (is_changeset ? "yaml" : "txt"))};
    const auto last_state_info{downloadFile(url)};
    // Find sequence number
    if (last_state_info->size() == 0) {
        log_error(_("Empty response retrieving last state from: %1%"), url);
        return std::make_shared<StateFile>();
    } else {
        const std::string last_state_str(last_state_info->begin(),
                                         last_state_info->end());
        static const std::regex re{R"re([\s\S]*sequenceNumber=(\d+)[\s\S]*)re"};
        static const std::regex yamlre{R"re([\s\S]*sequence: (\d+)[\s\S]*)re"};
        try {
            const long last_sequence = std::stol(std::regex_replace(
                last_state_str, is_changeset ? yamlre : re, "$1"));
            log_debug(_("Last sequence: %1%"), last_sequence);
            return fetchData(freq, last_sequence, underpass_dburl);
        } catch (const std::exception &ex) {
            log_error(_("Error converting sequenceNumber to long from: %1%"),
                      url);
            return std::make_shared<StateFile>();
        }
    }
}

std::shared_ptr<StateFile>
Planet::fetchDataFirst(frequency_t freq, const std::string &underpass_dburl,
                       bool force_scan)
{
    const bool is_changeset{freq == frequency_t::changeset};
    std::shared_ptr<StateFile> state =
        force_scan ? std::make_shared<StateFile>()
                   : fetchData(freq, is_changeset ? 0 : 1, underpass_dburl);
    // Go the hard way and scan the index
    if (!state->isValid()) {
        const auto base_path{"/replication/" + Underpass::freq_to_string(freq) +
                             '/'};
        auto path{base_path};
        std::string partial_path;
        bool scanning{true};
        while (scanning) {
            log_debug(_("Searching first data in %1% ..."), path);
            const auto links{scanDirectory(path)};
            if (links->size() > 0) {
                const auto first_link{links->at(0)};
                // First link is ???.osc.gz, second is the ???.state.txt that we are looking for
                if ((first_link.rfind(".osc.gz") != std::string::npos ||
                     first_link.rfind(".osm.gz") != std::string::npos) &&
                    links->size() > 1 &&
                    links->at(1).rfind(".state.txt") != std::string::npos) {
                    // Download
                    path.append(links->at(1));
                    partial_path.append(first_link.substr(0, 3));
                    const auto data{downloadFile(remote.url + path)};
                    if (data->size() == 0) {
                        log_debug(_("FetchDataFirst download failed for: %1%"),
                                  remote.url + path);
                    } else {
                        const std::string tmp_string{data->begin(),
                                                     data->end()};
                        state = std::make_shared<StateFile>(tmp_string, true);
                        state->path = '/' + partial_path;
                        state->frequency = Underpass::freq_to_string(freq);
                        log_debug(_("FetchDataFirst found %1% for: %2%"),
                                  state->sequence, remote.url + path);
                    }
                    scanning = false;
                } else if (is_changeset &&
                           first_link.rfind(".osm.gz") != std::string::npos) {
                    // An old changeset without state file
                    path.append(links->at(0));
                    partial_path.append(first_link.substr(0, 3));
                    const auto osm_gz_full_path{remote.url + path};
                    const auto data{downloadFile(osm_gz_full_path)};
                    if (data->size() == 0) {
                        log_debug(_("FetchDataFirst download failed for: %1%"),
                                  osm_gz_full_path);
                    } else {
                        // Extract timestamp from osm.gz
                        try {
                            boost::iostreams::filtering_streambuf<
                                boost::iostreams::input>
                                inbuf;
                            inbuf.push(boost::iostreams::gzip_decompressor());
                            boost::iostreams::array_source arrs{
                                reinterpret_cast<char const *>(data->data()),
                                data->size()};
                            inbuf.push(arrs);
                            std::istream instream(&inbuf);
                            try {
                                changeset::ChangeSetFile changeset;
                                changeset.readXML(instream);
                                if (changeset.changes.size() > 0) {
                                    const auto timestamp{
                                        changeset.changes.back()->closed_at};
                                    if (timestamp != not_a_date_time) {
                                        RemoteURL url;
                                        try {
                                            url.parse("https://" +
                                                      remote.domain +
                                                      osm_gz_full_path);
                                            state->frequency =
                                                Underpass::freq_to_string(freq);
                                            state->sequence = url.sequence();
                                            state->path = '/' + partial_path;
                                            state->timestamp = timestamp;
                                            state->closed_at = timestamp;
                                            state->created_at =
                                                changeset.changes.front()
                                                    ->created_at;
                                            log_debug(_("FetchDataFirst found "
                                                        "%1% for: %2%"),
                                                      state->sequence,
                                                      osm_gz_full_path);
                                            scanning = false;
                                        } catch (const std::exception &ex) {
                                            log_error(_("Couldn't get sequence "
                                                        "from: %1%"),
                                                      osm_gz_full_path);
                                        }
                                    } else {
                                        log_error(_("Couldn't get timestamp "
                                                    "from: %1%"),
                                                  osm_gz_full_path);
                                    }
                                } else {
                                    log_error(_("Couldn't parse empty: %1%"),
                                              osm_gz_full_path);
                                }
                            } catch (std::exception &e) {
                                log_error(_("Couldn't parse: %1% %2%"),
                                          osm_gz_full_path, e.what());
                            }
                        } catch (std::exception &e) {
                            log_error(_("%1% is corrupted!"), remote.url);
                        }
                        log_debug(
                            _("Timestamp extracted from osm.gz for path %1%"),
                            path);
                    }
                }
                partial_path.append(first_link);
                path.append(first_link);
            } else {
                log_debug(_("FetchDataFirst failed for: %1%"), path);
                scanning = false;
            }
        };
    }
    return state;
}

std::shared_ptr<StateFile>
Planet::fetchDataLessThan(frequency_t freq, ptime timestamp,
                          const std::string &underpass_dburl)
{
    std::shared_ptr<StateFile> state = std::make_shared<StateFile>();
    // First search in the cache
    bool use_cache{!underpass_dburl.empty()};
    Underpass underpass;
    if (use_cache) {
        if (!underpass.connect(underpass_dburl)) {
            log_error(_("Could not connect to underpass DB, caching disabled! "
                        "- DB URL: %1%"),
                      underpass_dburl);
        } else {
            state = underpass.getStateLessThan(freq, timestamp);
        }
    }

    // Cache miss or disabled?
    if (!state->isValid()) {
        log_debug(_("Cache miss for: %1% - %2%"),
                  Underpass::freq_to_string(freq),
                  to_iso_extended_string(timestamp));
        if (connectServer()) {
            state = fetchData(freq, 1, underpass_dburl);
            if (state->timestamp >= timestamp) {
                // The requested state is less than the first state.
                state = std::make_shared<StateFile>();
            } else {
                if (use_cache) {
                    if (!underpass.writeState(*state.get())) {
                        log_error(_("Could not store cached state in the "
                                    "underpass DB"));
                    }
                }
            }

        } else {
            log_error(
                _("Could not fetch data from URL: server is not connected!"));
        }
    } else {
        log_debug(_("Cache hit for: %1% - %2%"),
                  Underpass::freq_to_string(freq),
                  to_iso_extended_string(timestamp));
    }
    return state;
}

std::shared_ptr<StateFile>
Planet::fetchDataLessThan(frequency_t freq, long sequence,
                          const std::string &underpass_dburl)
{
    return fetchData(freq, sequence - 1, underpass_dburl);
}

std::shared_ptr<StateFile>
Planet::fetchData(frequency_t freq, ptime timestamp,
                  const std::string &underpass_dburl)
{
    std::shared_ptr<StateFile> state = std::make_shared<StateFile>();

    time_duration acceptable_delta;
    // Add some delta
    switch (freq) {
        case frequency_t::minutely:
            acceptable_delta = minutes{3};
            break;
        case frequency_t::hourly:
            acceptable_delta = hours{2};
            break;
        case frequency_t::daily:
            acceptable_delta = hours{25};
            break;
        case frequency_t::changeset:
            acceptable_delta = minutes{3};
            break;
    }

    // First search in the cache
    const bool use_cache{!underpass_dburl.empty()};
    Underpass underpass;
    if (use_cache) {
        if (!underpass.connect(underpass_dburl)) {
            log_error(_("Could not connect to underpass DB, caching disabled! "
                        "- DB URL: %1%"),
                      underpass_dburl);
        } else {
            const auto candidate{underpass.getState(freq, timestamp)};
            if ((candidate->timestamp - timestamp) < acceptable_delta) {
                state = candidate;
            }
        }
    }

    // abs is missing from boost 1.70
    const auto duration_abs = [](const time_duration &d) -> time_duration {
        return d.is_negative() ? d.invert_sign() : d;
    };

    // Cache miss or disabled?
    if (!state->isValid()) {
        log_debug(_("Cache miss for: %1% - %2%"),
                  Underpass::freq_to_string(freq),
                  to_iso_extended_string(timestamp));
        // We need a range for the search
        auto greater_state{
            fetchDataGreaterThan(freq, timestamp, underpass_dburl)};
        auto lesser_state{fetchDataLessThan(freq, timestamp, underpass_dburl)};
        // Since the previous calls do not return valid states for equality
        // we need to check the boundaries
        if (!greater_state->isValid() || !lesser_state->isValid()) {
            const auto first_state{fetchDataFirst(freq, underpass_dburl)};
            if (duration_abs(first_state->timestamp - timestamp) <
                acceptable_delta) {
                state = first_state;
            }
            if (!state->isValid()) {
                const auto last_state{fetchDataLast(freq, underpass_dburl)};
                if (duration_abs(last_state->timestamp - timestamp) <
                    acceptable_delta) {
                    state = last_state;
                }
            }
        } else {
            // Start interpolation
            unsigned int loop_counter{0};
            long old_sequence_candidate{-1};
            long offset{0};
            while (loop_counter < 10) {
                const auto distance_seconds{
                    (greater_state->timestamp - lesser_state->timestamp)
                        .total_seconds()};
                const auto lower_end_seconds{
                    (timestamp - lesser_state->timestamp).total_seconds()};
                const double ratio{static_cast<double>(lower_end_seconds) /
                                   distance_seconds};
                long sequence_candidate{static_cast<long>(
                    lesser_state->sequence +
                    std::max<long>(
                        1, (greater_state->sequence - lesser_state->sequence) *
                               ratio))};
                // Here comes the fun part, sometimes the sequence number for
                // changesets is off by one, so we cannot really exit here
                if (offset < 1 &&
                    sequence_candidate == old_sequence_candidate) {
                    offset++;
                    sequence_candidate++;
                }
                if (sequence_candidate != old_sequence_candidate) {
                    old_sequence_candidate = sequence_candidate;
                    const auto candidate{
                        fetchData(freq, sequence_candidate, underpass_dburl)};
                    log_debug(
                        _("Checking candidate for %1% (loop: %2%) %3% - %4%"),
                        to_iso_extended_string(timestamp), loop_counter,
                        to_iso_extended_string(candidate->timestamp),
                        candidate->sequence);
                    if (!candidate->isValid()) {
                        log_debug(_("No valid state for timestamp: %1% - "
                                    "candidate is not valid."),
                                  to_iso_extended_string(timestamp));
                        loop_counter = 10;
                    } else {
                        // Check if it is within time range
                        if (duration_abs(candidate->timestamp - timestamp) <
                                acceptable_delta &&
                            candidate->timestamp >= timestamp) {
                            log_debug(_("State found for timestamp: %1% - "
                                        "loops: %2%."),
                                      to_iso_extended_string(timestamp),
                                      loop_counter);
                            state = candidate;
                            loop_counter = 10;
                        } else if (candidate->timestamp < timestamp) {
                            lesser_state = candidate;
                        } else if (candidate->timestamp > timestamp) {
                            greater_state = candidate;
                        }
                    }
                    loop_counter++;
                } else {
                    log_debug(_("No valid state for timestamp: %1% - end of "
                                "candidates."),
                              to_iso_extended_string(timestamp));
                    loop_counter = 10;
                }
            } // loop end
        }
    } else {
        log_debug(_("Cache hit for: %1% - %2%"),
                  Underpass::freq_to_string(freq),
                  to_iso_extended_string(timestamp));
    }

    if (!state->isValid()) {
        log_debug(_("No valid state for timestamp: %1%."),
                  to_iso_extended_string(timestamp));
    } else {
        // We need to make sure that there isn't a closer match within the freq acceptable_delta
        const auto previous_candidate{fetchData(freq, state->sequence - 1)};
        if (previous_candidate->isValid() &&
            previous_candidate->timestamp >= timestamp) {
            state = previous_candidate;
            log_debug(_("Previous state found for timestamp %1% : %2%."),
                      to_iso_extended_string(timestamp), state->sequence);
        }
    }
    return state;
}

std::shared_ptr<StateFile>
Planet::fetchData(frequency_t freq, long sequence,
                  const std::string &underpass_dburl)
{
    std::shared_ptr<StateFile> state = std::make_shared<StateFile>();
    if (sequence < (freq == frequency_t::changeset ? 0 : 1)) {
        log_error(_("Invalid sequence (must be > 0 for changes and >= 0 for "
                    "changesets)!"));
        return state;
    }

    bool use_cache{!underpass_dburl.empty()};
    Underpass underpass;

    // First search in the cache
    if (use_cache) {
        if (!underpass.connect(underpass_dburl)) {
            log_error(_("Could not connect to underpass DB, caching disabled! "
                        "- DB URL: %1%"),
                      underpass_dburl);
            use_cache = false;
        } else {
            state = underpass.getState(freq, sequence);
        }
    }
    // Cache miss or disabled?
    if (!state->isValid()) {
        log_debug(_("Cache miss for: %1% - sequence: %2%"),
                  Underpass::freq_to_string(freq), sequence);
        if (connectServer()) {
            state = fetchData(freq, sequenceToPath(sequence), underpass_dburl);
            // Might be off by one on changesets
            if (state->sequence == sequence - 1) {
                log_debug(_("Offsetting +1 sequence: %1%"), sequence);
                state = fetchData(freq, sequenceToPath(sequence + 1),
                                  underpass_dburl);
            }
            if (state->isValid()) {
                if (use_cache) {
                    if (!underpass.writeState(*state.get())) {
                        log_error(_("Could not store cached state in the "
                                    "underpass DB"));
                    }
                }
            } else {
                log_error(_("Invalid state fetched for sequence: %1%"),
                          sequence);
            }

        } else {
            log_error(
                _("Could not fetch data from URL: server is not connected!"));
        }
    } else {
        log_debug(_("Cache hit for: %1% - sequence: %2%"),
                  Underpass::freq_to_string(freq), sequence);
    }
    return state;
}

std::shared_ptr<StateFile>
Planet::fetchDataGreaterThan(frequency_t freq, long sequence,
                             const std::string &underpass_dburl)
{
    return fetchData(freq, sequence + 1, underpass_dburl);
}

std::shared_ptr<StateFile>
Planet::fetchDataGreaterThan(frequency_t freq, ptime timestamp,
                             const std::string &underpass_dburl)
{
    std::shared_ptr<StateFile> state = std::make_shared<StateFile>();
    // First search in the cache
    bool use_cache{!underpass_dburl.empty()};
    Underpass underpass;
    if (use_cache) {
        if (!underpass.connect(underpass_dburl)) {
            log_error(_("Could not connect to underpass DB, caching disabled! "
                        "- DB URL: %1%"),
                      underpass_dburl);
            use_cache = false;
        } else {
            state = underpass.getStateGreaterThan(freq, timestamp);
        }
    }

    // Cache miss or disabled?
    if (!state->isValid()) {
        log_debug(_("Cache miss for: %1% - %2%"),
                  Underpass::freq_to_string(freq),
                  to_iso_extended_string(timestamp));
        if (connectServer()) {
            state = fetchDataLast(freq, underpass_dburl);
            if (state->timestamp <= timestamp) {
                // The requested state is greater than the last state.
                state = std::make_shared<StateFile>();
            } else {
                if (use_cache) {
                    if (!underpass.writeState(*state.get())) {
                        log_error(_("Could not store cached state in the "
                                    "underpass DB"));
                    }
                }
            }

        } else {
            log_error(
                _("Could not fetch data from URL: server is not connected!"));
        }
    } else {
        log_debug(_("Cache hit for: %1% - %2%"),
                  Underpass::freq_to_string(freq),
                  to_iso_extended_string(timestamp));
    }
    return state;
}

RemoteURL::RemoteURL(void) : major(0), minor(0), index(0), frequency(minutely)
{
}

void
RemoteURL::parse(const std::string &rurl)
{
    if (rurl.empty()) {
        log_error(_("URL is empty!"));
        return;
    }

    std::vector<std::string> parts;
    boost::split(parts, rurl, boost::is_any_of("/"));
    if (parts.size() == 8) {
        domain = parts[2];
        datadir = parts[3];
        subpath = parts[5] + "/" + parts[6] + "/" + parts[7];
        try {
            frequency = Underpass::freq_from_string(parts[4]);
            major = std::stoi(parts[5]);
            minor = std::stoi(parts[6]);
            index = std::stoi(parts[7]);
        } catch (const std::exception &ex) {
            log_error(_("Error parsing URL: %1%"), ex.what());
        }
        if (frequency == replication::changeset) {
            filespec = rurl.substr(rurl.find(datadir)) + ".osm.gz";
            url = rurl + ".osm.gz";
        } else {
            filespec = rurl.substr(rurl.find(datadir)) + ".osc.gz";
            url = rurl + ".osc.gz";
        }
        destdir = datadir + "/" + parts[4] + "/" + parts[5] + "/" + parts[6];
    } else {
        log_error(_("Error parsing URL %1%: not in the expected form "
                    "(https://<server>/replication/<frequency>/000/000/001)"),
                  rurl);
    }
}

void
RemoteURL::Increment(void)
{
    boost::format majorfmt("%03d");
    boost::format minorfmt("%03d");
    boost::format indexfmt("%03d");
    std::string newpath;
    if (minor == 999) {
        major++;
        minor = 0;
        index = 0;
    }
    if (index == 999) {
        minor++;
        index = 0;
    } else {
        index++;
    }

    majorfmt % (major);
    minorfmt % (minor);
    indexfmt % (index);

    newpath = majorfmt.str() + "/" + minorfmt.str() + "/" + indexfmt.str();
    // log_debug(_("NEWPATH: " << newpath);
    boost::algorithm::replace_all(url, subpath, newpath);
    boost::algorithm::replace_all(destdir, subpath, newpath);
    boost::algorithm::replace_all(filespec, subpath, newpath);
    boost::algorithm::replace_all(url, subpath, newpath);
    subpath = newpath;
}

RemoteURL &
RemoteURL::operator=(const RemoteURL &inr)
{
    domain = inr.domain;
    datadir = inr.datadir;
    subpath = inr.subpath;
    frequency = inr.frequency;
    major = inr.major;
    minor = inr.minor;
    index = inr.index;
    url = inr.url;
    filespec = inr.filespec;
    destdir = inr.destdir;

    return *this;
}

long
RemoteURL::sequence()
{
    return major * 1000000 + minor * 1000 + index;
}

RemoteURL::RemoteURL(const RemoteURL &inr)
{
    domain = inr.domain;
    datadir = inr.datadir;
    subpath = inr.subpath;
    frequency = inr.frequency;
    major = inr.major;
    minor = inr.minor;
    index = inr.index;
    url = inr.url;
    filespec = inr.filespec;
    destdir = inr.destdir;
}

void
RemoteURL::dump(void)
{
    std::cerr << "URL: " << url << std::endl;
    std::cerr << "\tDomain: " << domain << std::endl;
    std::cerr << "\tDatadir: " << datadir << std::endl;
    std::cerr << "\tSubpath: " << subpath << std::endl;
    std::cerr << "\tURL: " << url << std::endl;
    std::map<frequency_t, std::string> freqs;
    freqs[replication::minutely] = "minute";
    freqs[replication::hourly] = "hour";
    freqs[replication::daily] = "day";
    freqs[replication::changeset] = "changesets";
    std::cerr << "\tFrequency: " << (int)frequency << std::endl;
    std::cerr << "\tMajor: " << major << std::endl;
    std::cerr << "\tMinor: " << minor << std::endl;
    std::cerr << "\tIndex: " << index << std::endl;
    std::cerr << "\tFilespec: " << filespec << std::endl;
    std::cerr << "\tDestdir: " << destdir << std::endl;
}

} // namespace replication
