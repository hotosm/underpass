//
// Copyright (c) 2023, 2024 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

/// \file queryraw.cc
/// \brief This file is used to work with the OSM Raw database
///
/// This manages the OSM Raw schema in a PostgreSQL database, 
/// including querying existing data in the database, as well as
/// updating the database.

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <iostream>
#include <boost/timer/timer.hpp>
#include <boost/format.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <map>
#include <string>
#include "utils/log.hh"
#include "data/pq.hh"
#include "raw/queryraw.hh"
#include "osm/osmobjects.hh"
#include "osm/osmchange.hh"

#include <boost/timer/timer.hpp>

using namespace pq;
using namespace logger;
using namespace osmobjects;
using namespace osmchange;

/// \namespace queryraw
namespace queryraw {

QueryRaw::QueryRaw(void) {}

QueryRaw::QueryRaw(std::shared_ptr<Pq> db) {
    dbconn = db;
}

// Receives a dictionary of tags (key: value) and returns
// a JSONB string for doing an insert operation into the database.
std::string
QueryRaw::buildTagsQuery(std::map<std::string, std::string> tags) const {
    if (tags.size() > 0) {
        std::string tagsStr = "jsonb_build_object(";
        int count = 0;
        for (auto it = std::begin(tags); it != std::end(tags); ++it) {
            ++count;
            // PostgreSQL has an argument limit for functions (100 parameters max)
            // Because of this, when the count of key/value pairs reaches 50, 
            // a concatenation of multiple calls to the jsonb_build_object() function 
            // is needed.
            if (count == 50) {
                tagsStr.erase(tagsStr.size() - 1);
                tagsStr += ") || jsonb_build_object(";
                count = 0;
            }
            std::string tag_format = "'%s', '%s',";
            boost::format tag_fmt(tag_format);
            tag_fmt % dbconn->escapedString(dbconn->escapedJSON(it->first));
            tag_fmt % dbconn->escapedString(dbconn->escapedJSON(it->second));
            tagsStr += tag_fmt.str();
        }
        tagsStr.erase(tagsStr.size() - 1);
        return tagsStr + ")";
    } else {
        return "null";
    }
}

// Receives a list of Relation members and returns
// a JSONB string for doing an insert operation into the database.
std::string
buildMembersQuery(std::list<OsmRelationMember> members) {
    if (members.size() > 0) {
        std::string membersStr = "'[";
        for (auto mit = std::begin(members); mit != std::end(members); ++mit) {
            membersStr += "{";
            std::string member_format = "\"%s\": \"%s\",";
            boost::format member_fmt(member_format);
            member_fmt % "role";
            member_fmt % mit->role;
            membersStr += member_fmt.str();
            member_fmt % "type";
            switch(mit->type) {
                case osmobjects::osmtype_t::way:
                    member_fmt % "way"; break;
                case osmobjects::osmtype_t::node:
                    member_fmt % "node"; break;
                case osmobjects::osmtype_t::relation:
                    member_fmt % "relation"; break;
                default:
                    member_fmt % "";
            }
            membersStr += member_fmt.str();
            membersStr += "\"ref\":";
            membersStr += std::to_string(mit->ref);
            membersStr += "},";
        }
        membersStr.erase(membersStr.size() - 1);

        return membersStr += "]'";
    } else {
        return "null";
    }
}

// Parses a JSON object from a string and return a map of key/value.
// This function is useful for parsing tags from a query result.
std::map<std::string, std::string> parseJSONObjectStr(std::string input) {
    std::map<std::string, std::string> obj;
    boost::property_tree::ptree pt;
    try {
        std::istringstream jsonStream(input);
        boost::property_tree::read_json(jsonStream, pt);
    } catch (const boost::property_tree::json_parser::json_parser_error& e) {
        std::cerr << "Error parsing JSON: " << e.what() << std::endl;
        return obj;
    }
    for (const auto& pair : pt) {
        obj[pair.first] = pair.second.get_value<std::string>();
    }
    return obj;
}

// Parses a JSON object from a string and return a vector of key/value maps
// This function is useful for parsing relation members from a query result.
std::vector<std::map<std::string, std::string>> parseJSONArrayStr(std::string input) {
    std::vector<std::map<std::string, std::string>> arr;
    boost::property_tree::ptree pt;
    try {
        std::istringstream jsonStream(input);
        boost::property_tree::read_json(jsonStream, pt);
    } catch (const boost::property_tree::json_parser::json_parser_error& e) {
        std::cerr << "Error parsing JSON: " << e.what() << std::endl;
        return arr;
    }

    for (const auto& item : pt) {
        std::map<std::string, std::string> obj;
        for (const auto& pair : item.second) {
            obj[pair.first] = pair.second.get_value<std::string>();
        }
        arr.push_back(obj);
    }

    return arr;
}


// Apply the change for a Node. It will return a string of a query for
// insert, update or delete the Node in the database.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmNode &node) const
{
    auto queries = std::make_shared<std::vector<std::string>>();

    // If create or modify, then insert or update
    if (node.action == osmobjects::create || node.action == osmobjects::modify) {
        std::string query = "INSERT INTO nodes as r (osm_id, geom, tags, timestamp, version, \"user\", uid, changeset) VALUES(";
        std::string format = "%d, ST_GeomFromText(\'%s\', 4326), %s, \'%s\', %d, \'%s\', %d, %d \
        ) ON CONFLICT (osm_id) DO UPDATE SET  geom = ST_GeomFromText(\'%s\', \
        4326), tags = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version < %d;";
        boost::format fmt(format);

        // osm_id
        fmt % node.id;

        // geometry
        std::stringstream ss;
        ss << std::setprecision(12) << bg::wkt(node.point);
        std::string geometry = ss.str();
        fmt % geometry;

        // tags
        auto tags = buildTagsQuery(node.tags);
        fmt % tags;
        // timestamp
        std::string timestamp = to_simple_string(boost::posix_time::microsec_clock::universal_time());
        fmt % timestamp;
        // version
        fmt % node.version;
        // user
        fmt % dbconn->escapedString(node.user);
        // uid
        fmt % node.uid;
        // changeset
        fmt % node.changeset;

        // ON CONFLICT (update)
        fmt % geometry;
        fmt % tags;
        fmt % timestamp;
        fmt % node.version;
        fmt % dbconn->escapedString(node.user);
        fmt % node.uid;
        fmt % node.changeset;
        fmt % node.version;

        query.append(fmt.str());
        queries->push_back(query);

    // If remove, then delete the object
    } else if (node.action == osmobjects::remove) {
        queries->push_back("DELETE from nodes where osm_id = " + std::to_string(node.id) + ";");
    }

    return queries;
}

const std::string QueryRaw::polyTable = "ways_poly";
const std::string QueryRaw::lineTable = "ways_line";

// Apply the change for a Way. It will return a string of a query for
// insert, update or delete the Way in the database.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmWay &way) const
{
    auto queries = std::make_shared<std::vector<std::string>>();
    std::string query;
    const std::string* tableName;

    // Get a Polygon or LineString geometry string depending on the Way
    std::stringstream ss;
    if (way.refs.size() > 3 && (way.refs.front() == way.refs.back())) {
        tableName = &QueryRaw::polyTable;
        ss << std::setprecision(12) << bg::wkt(way.polygon);
    } else {
        tableName = &QueryRaw::lineTable;
        ss << std::setprecision(12) << bg::wkt(way.linestring);
    }
    std::string geostring = ss.str();

    // Make sure we have what's needed to insert or update a Way:
    // - At least 2 points
    // - A LineString or a Polygon
    // - A create, modify or "modify geometry" action.
    if (way.refs.size() > 0
        && (way.action == osmobjects::create || way.action == osmobjects::modify || way.action == osmobjects::modify_geom)) {
        if ((way.refs.front() != way.refs.back() && way.refs.size() == bg::num_points(way.linestring)) ||
            (way.refs.front() == way.refs.back() && way.refs.size() == bg::num_points(way.polygon))
         ) {

            // Insert or update the full Way, including id, tags, refs, geometry, timestamp, version,
            // user, uid and changeset
            if (way.action != osmobjects::modify_geom) {

                query = "INSERT INTO " + *tableName + " as r (osm_id, tags, refs, geom, timestamp, version, \"user\", uid, changeset) VALUES(";
                std::string format = "%d, %s, %s, %s, \'%s\', %d, \'%s\', %d, %d) \
                ON CONFLICT (osm_id) DO UPDATE SET tags = %s, refs = %s, geom = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version <= %d;";
                boost::format fmt(format);

                // osm_id
                fmt % way.id;

                // tags
                auto tags = buildTagsQuery(way.tags);
                fmt % tags;

                // refs
                std::string refs = "";
                for (auto it = std::begin(way.refs); it != std::end(way.refs); ++it) {
                    refs += std::to_string(*it) + ",";
                }
                refs.erase(refs.size() - 1);
                refs = "ARRAY[" + refs + "]";
                fmt % refs;

                // geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // timestamp (now)
                std::string timestamp = to_simple_string(boost::posix_time::microsec_clock::universal_time());
                fmt % timestamp;
                // version
                fmt % way.version;
                // user
                fmt % dbconn->escapedString(way.user);
                // uid
                fmt % way.uid;
                // changeset
                fmt % way.changeset;

                // ON CONFLICT (update)
                fmt % tags;
                fmt % refs;
                fmt % geometry;
                fmt % timestamp;
                fmt % way.version;
                fmt % dbconn->escapedString(way.user);
                fmt % way.uid;
                fmt % way.changeset;
                fmt % way.version;

                query += fmt.str();
                queries->push_back(query);

            } else {

                // Update only the Way's geometry. This is the case when a Way was indirectly 
                // modified by a change on some referenced Node; the geometry of the Way will
                // change but all other data (tags, version, etc) will remain the same.

                query = "UPDATE " + *tableName + " SET ";
                std::string format = "geom=%s, timestamp=\'%s\' WHERE osm_id=%d;";
                boost::format fmt(format);

                // Geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // Timestamp (now)
                std::string timestamp = to_simple_string(boost::posix_time::microsec_clock::universal_time());
                fmt % timestamp;

                // osm_id
                fmt % way.id;

                query += fmt.str();
                queries->push_back(query);
            }

            // If the Way's geometry is a LineString, remove all Polygons from the Polygons table.
            // If the Way's geometry is a Polygon, remove all LineString from the LineStrings table.
            // This is for preventing duplicated Way geometries. For example, when the Way was a
            // LineString but it was then closed and converted to a Polygon.
            std::string delquery = "DELETE FROM %s WHERE osm_id=%d;";
            boost::format delquery_fmt(delquery);
            if (tableName == &QueryRaw::polyTable) {
                delquery_fmt % QueryRaw::lineTable;
            } else {
                delquery_fmt % QueryRaw::polyTable;
            }
            delquery_fmt % way.id;
            queries->push_back(delquery_fmt.str());
        }
    } else if (way.action == osmobjects::remove) {
        // Delete a Way geometry and its references.
        if (tableName == &QueryRaw::polyTable) {
            queries->push_back("DELETE FROM " + QueryRaw::polyTable + " where osm_id = " + std::to_string(way.id) + ";");
        } else {
            queries->push_back("DELETE FROM " + QueryRaw::lineTable + " where osm_id = " + std::to_string(way.id) + ";");
        }
    }

    return queries;
}

// Apply the change for a Relation. It will return a string of a query for
// insert, update or delete the Relation in the database.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmRelation &relation) const
{
    auto queries = std::make_shared<std::vector<std::string>>();
    std::string query;

    // Create, modify or modify the geometry of a Relation
    if (relation.action == osmobjects::create || relation.action == osmobjects::modify || relation.action == osmobjects::modify_geom) {

        // Get a Polygon or LineString geometry string depending on the Relation
        std::stringstream ss;
        if (relation.isMultiPolygon()) {
            ss << std::setprecision(12) << bg::wkt(relation.multipolygon);
        } else {
            ss << std::setprecision(12) << bg::wkt(relation.multilinestring);
        }
        std::string geostring = ss.str();

        // Ignore empty geometries
        if (geostring != "MULTILINESTRING()" && geostring != "POLYGON()"
            && geostring != "MULTILINESTRING(())" && geostring != "POLYGON(())") {

            // Insert or update the full Relation, including id, tags, refs, geometry, timestamp,
            // version, user, uid and changeset
            if (relation.action != osmobjects::modify_geom) {

                query = "INSERT INTO relations as r (osm_id, tags, refs, geom, timestamp, version, \"user\", uid, changeset) VALUES(";
                std::string format = "%d, %s, %s, %s, \'%s\', %d, \'%s\', %d, %d) \
                ON CONFLICT (osm_id) DO UPDATE SET tags = %s, refs = %s, geom = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version <= %d;";
                boost::format fmt(format);

                // osm_id
                fmt % relation.id;

                // tags
                auto tags = buildTagsQuery(relation.tags);
                fmt % tags;

                // refs
                auto refs = buildMembersQuery(relation.members);
                fmt % refs;

                // geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // timestamp (now)
                std::string timestamp = to_simple_string(boost::posix_time::microsec_clock::universal_time());
                fmt % timestamp;
                // version
                fmt % relation.version;
                // user
                fmt % dbconn->escapedString(relation.user);
                // uid
                fmt % relation.uid;
                // changeset
                fmt % relation.changeset;

                // ON CONFLICT
                fmt % tags;
                fmt % refs;
                fmt % geometry;
                fmt % timestamp;
                fmt % relation.version;
                fmt % dbconn->escapedString(relation.user);
                fmt % relation.uid;
                fmt % relation.changeset;
                fmt % relation.version;

                query.append(fmt.str());
                queries->push_back(query);

            } else {

                // Update only the Relation's geometry. This is the case when a Relation was indirectly 
                // modified by a change on some referenced Way; the geometry of the Relation will
                // change but all other data (tags, version, etc) will remain the same.

                query = "UPDATE relations SET ";
                std::string format = "geom=%s, timestamp=\'%s\' WHERE osm_id=%d;";
                boost::format fmt(format);

                // Geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // Timestamp
                std::string timestamp = to_simple_string(boost::posix_time::microsec_clock::universal_time());
                fmt % timestamp;

                // osm_id
                fmt % relation.id;

                query.append(fmt.str());
                queries->push_back(query);
            }
        }
    } else if (relation.action == osmobjects::remove) {
        // Delete a Relation geometry and its references.
        queries->push_back("DELETE FROM relations where osm_id = " + std::to_string(relation.id) + ";");
    }

    return queries;
}

// Receives a string of comma separated values and
// returns a vector. This function is useful for
// getting a vector of references from a query result
std::vector<long> arrayStrToVector(std::string refs_str) {
    refs_str.erase(0, 1);
    refs_str.erase(refs_str.size() - 1);
    std::vector<long> refs;
    std::stringstream ss(refs_str);
    std::string token;
    while (std::getline(ss, token, ',')) {
        refs.push_back(std::stod(token));
    }
    return refs;
}

// Get all Relations that have at least 1 reference to any Way
// of a list. This function receives a string of comma separated
// ids ("213213,328947,287313") and returns a list of Relation
// objects. This is useful for getting Relations that were
// indirectly modified by a change on a Way.
std::list<std::shared_ptr<OsmRelation>>
QueryRaw::getRelationsByWaysRefs(std::string &wayIds) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getRelationsByWaysRefs(wayIds): took %w seconds\n");
#endif
    // Object to return
    std::list<std::shared_ptr<osmobjects::OsmRelation>> rels;

    // Query for getting Relations
    std::string relsQuery = "SELECT distinct(osm_id), refs, version, tags, uid, changeset FROM relations WHERE EXISTS (SELECT 1 FROM jsonb_array_elements(refs) AS ref WHERE (ref->>'ref')::bigint IN (" + wayIds + "));";
    auto rels_result = dbconn->query(relsQuery);

    // Fill vector with OsmRelation objects
    for (auto rel_it = rels_result.begin(); rel_it != rels_result.end(); ++rel_it) {
        auto rel = std::make_shared<OsmRelation>();
        rel->id = (*rel_it)[0].as<long>();
        std::string refs_str = (*rel_it)[1].as<std::string>();
        auto members = parseJSONArrayStr(refs_str);

        for (auto mit = members.begin(); mit != members.end(); ++mit) {
            auto memberType = osmobjects::osmtype_t::way;
            if (mit->at("type") == "n") {
                memberType = osmobjects::osmtype_t::node;
            } else if (mit->at("type") == "r") {
                memberType = osmobjects::osmtype_t::relation;
            }
            rel->addMember(std::stol(mit->at("ref")), memberType, mit->at("role"));
        }
        
        rel->version = (*rel_it)[2].as<long>();
        auto tags = (*rel_it)[3];
        if (!tags.is_null()) {
            auto tags = parseJSONObjectStr((*rel_it)[3].as<std::string>());
            for (auto const& [key, val] : tags)
            {
                rel->addTag(key, val);
            }
        }
        auto uid = (*rel_it)[4];
        if (!uid.is_null()) {
            rel->uid = (*rel_it)[4].as<long>();
        }
        auto changeset = (*rel_it)[5];
        if (!changeset.is_null()) {
            rel->changeset = (*rel_it)[5].as<long>();
        }
        rels.push_back(rel);
    }
    return rels;
}

// Receives a string with a list of Way ids, get them from the database and store them
// on a Way cache
void
QueryRaw::getWaysByIds(std::string &waysIds, std::map<long, std::shared_ptr<osmobjects::OsmWay>> &waycache) {
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getWaysByIds(waysIds, waycache): took %w seconds\n");
#endif
    // Get Ways and it's geometries (Polygon and LineString)
    std::string waysQuery = "SELECT distinct(osm_id), ST_AsText(geom, 4326), 'polygon' as type from ways_poly wp where osm_id = any(ARRAY[" + waysIds + "]) ";
    waysQuery += "UNION SELECT distinct(osm_id), ST_AsText(geom, 4326), 'linestring' as type from ways_line wp where osm_id = any(ARRAY[" + waysIds + "]);";
    auto ways_result = dbconn->query(waysQuery);
    if (ways_result.size() == 0) {
        log_debug("No results returned!");
        return;
    }

    std::string resultIds = "";

    // Insert Ways into waycache
    for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
        auto way = std::make_shared<OsmWay>();
        auto type = (*way_it)[2].as<std::string>();
        way->id = (*way_it)[0].as<long>();
        if (type == "polygon") {
            bg::read_wkt((*way_it)[1].as<std::string>(), way->polygon);
        } else {
            bg::read_wkt((*way_it)[1].as<std::string>(), way->linestring);
        }
        waycache.insert(std::pair(way->id, std::make_shared<osmobjects::OsmWay>(*way)));
    }
}

// Receives a list of Osm Changes and the priority area and completes the geometry of
// all objects (Nodes, Ways and Realations), including all indirectly modified objects.
//
// Incomplete geometries happens all the time on Ways and Relations because the data for
// they geometries (coordinates) can be not present on the OsmChange file. For example
// if the tags of a Way are modified, but not it's references, only the tag information
// will be on the OsmChange file, but not the coordinates for the referenced Nodes.
//
// An indirectly modified object is the one whose geometry was modified by a modification
// on the geometry of one of its references. For example, if a Node is modified and that
// Node is referenced on a Way, the Way's geometry must to be updated. Also, if that Way
// is referenced on a Relation, then the Relation's geometry must be updated too.
//
// TODO: divide this function into multiple ones
//
void QueryRaw::buildGeometries(std::shared_ptr<OsmChangeFile> osmchanges, const multipolygon_t &poly)
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("buildGeometries(osmchanges, poly): took %w seconds\n");
#endif
    std::string referencedNodeIds;
    std::string modifiedNodesIds;
    std::string modifiedWaysIds;
    std::vector<long> removedWays;
    std::vector<long> removedRelations;

    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto wit = std::begin(change->ways); wit != std::end(change->ways); ++wit) {
            OsmWay *way = wit->get();
            if (way->action != osmobjects::remove) {

                // Save referenced Nodes ids for later use. The geometries of these
                // Nodes will be needed later when building geometries for Ways
                for (auto rit = std::begin(way->refs); rit != std::end(way->refs); ++rit) {
                    if (!osmchanges->nodecache.count(*rit)) {
                        referencedNodeIds += std::to_string(*rit) + ",";
                    }
                }
                // Save Ways in waycache, pre-filter by priority area
                if (poly.empty() || bg::within(way->linestring, poly)) {
                    osmchanges->waycache.insert(std::make_pair(way->id, std::make_shared<osmobjects::OsmWay>(*way)));
                }
            } else {
                // Save removed Ways for later use. This list will be used to known
                // which Ways will be skipped when building geometries
                removedWays.push_back(way->id);
            }
        }

        // Save modified nodes for later use. This list will be used for getting
        // indirectly modified Ways
        for (auto nit = std::begin(change->nodes); nit != std::end(change->nodes); ++nit) {
            OsmNode *node = nit->get();
            if (node->action == osmobjects::modify) {
                // Get only modified nodes ids inside the priority area
                if (poly.empty() || bg::within(node->point, poly)) {
                    modifiedNodesIds += std::to_string(node->id) + ",";
                }
            }
        }

        // Save removed Relations for later use. This list will be used to known
        // which Relations will be skipped when building geometries
        for (auto rel_it = std::begin(change->relations); rel_it != std::end(change->relations); ++rel_it) {
            OsmRelation *relation = rel_it->get();
            removedRelations.push_back(relation->id);
        }
    }

    // Add indirectly modified ways to osmchanges. An indirectly modified Way is a Way
    // whose geoemtry was modified because one of it's referenced Nodes was modified
    if (modifiedNodesIds.size() > 1) {
        modifiedNodesIds.erase(modifiedNodesIds.size() - 1);

        // Get all Ways that have at least one reference to one of the modified Nodes
        auto modifiedWays = getWaysByNodesRefs(modifiedNodesIds);

        // Add a new change for the indirectly modified Way
        auto change = std::make_shared<OsmChange>(none);
        for (auto wit = modifiedWays.begin(); wit != modifiedWays.end(); ++wit) {
           auto way = std::make_shared<OsmWay>(*wit->get());
           // If the Way is not removed
           if (std::find(removedWays.begin(), removedWays.end(), way->id) == removedWays.end()) {

                // Save referenced Nodes. This list will be used for getting the geometries of
                // these Nodes, used when building the Way geometry
                for (auto rit = std::begin(way->refs); rit != std::end(way->refs); ++rit) {
                    if (!osmchanges->nodecache.count(*rit)) {
                        referencedNodeIds += std::to_string(*rit) + ",";
                    }
                }

                // Flag it as modified geometry. This means that only the geometry was modified,
                // nor its tags, version, etc.
                way->action = osmobjects::modify_geom;

                // Add the Way to the list of Ways in the OsmChange
                change->ways.push_back(way);

                // Save the id of the indirectly modified Way for later use. This will be used
                // for identifying which Relations were indirectly modified by this change.
                modifiedWaysIds += std::to_string(way->id) + ",";
           }
        }
        osmchanges->changes.push_back(change);
    }

    // Add indirectly modified Relations to osmchanges. This is the case when a Way referenced
    // in a Relation was modified (or indirectly modified by a change on one of its Nodes)
    if (modifiedWaysIds.size() > 1) {

        // Get indirectly modified Relations from the DB, using the list of Ways
        // that were modified
        modifiedWaysIds.erase(modifiedWaysIds.size() - 1);
        auto modifiedRelations = getRelationsByWaysRefs(modifiedWaysIds);

        // Create a new change for the indirecty modified Relation
        auto change = std::make_shared<OsmChange>(none);
        for (auto rel_it = modifiedRelations.begin(); rel_it != modifiedRelations.end(); ++rel_it) {
           auto relation = std::make_shared<OsmRelation>(*rel_it->get());
           // If the Relation is not removed
           if (std::find(removedRelations.begin(), removedRelations.end(), relation->id) == removedRelations.end()) {
                // Flag it as modified geometry. This means that only the geometry was modified,
                // nor its tags, version, etc.
                relation->action = osmobjects::modify_geom;

                // Add the Relation to the list of Relation in the OsmChange
                change->relations.push_back(relation);
           }
        }
        osmchanges->changes.push_back(change);
    }

    // Fill nodecache with referenced Nodes. This will be used later when building the
    // geometries of Ways
    if (referencedNodeIds.size() > 1) {
        referencedNodeIds.erase(referencedNodeIds.size() - 1);
        // Get Nodes geoemtries from DB
        std::string nodesQuery = "SELECT osm_id, st_x(geom) as lat, st_y(geom) as lon FROM nodes where osm_id in (" + referencedNodeIds + ");";
        auto result = dbconn->query(nodesQuery);
        if (result.size() == 0) {
            log_debug("No results returned!");
            return;
        }
        // Fill nodecache
        for (auto node_it = result.begin(); node_it != result.end(); ++node_it) {
            auto node_id = (*node_it)[0].as<long>();
            auto node_lat = (*node_it)[2].as<double>();
            auto node_lon = (*node_it)[1].as<double>();
            OsmNode node(node_lat, node_lon);
            osmchanges->nodecache[node_id] = node.point;
        }
    }

    // Build Ways geometries using nodecache
    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto wit = std::begin(change->ways); wit != std::end(change->ways); ++wit) {
            OsmWay *way = wit->get();

            // Only build geometries for Ways with incomplete geometries
            if (bg::num_points(way->linestring) != way->refs.size()) {
                way->linestring.clear();
                for (auto rit = way->refs.begin(); rit != way->refs.end(); ++rit) {
                    if (osmchanges->nodecache.count(*rit)) {
                        bg::append(way->linestring, osmchanges->nodecache.at(*rit));
                    }
                }
                if (way->isClosed()) {
                    way->polygon = { {std::begin(way->linestring), std::end(way->linestring)} };
                    way->linestring.clear();
                }
            }

            // Save Way pointer for later use. This will be used when building Relations geometries.
            if (poly.empty() || bg::within(way->linestring, poly)) {
                if (osmchanges->waycache.count(way->id)) {
                    if (way->isClosed()) {
                        osmchanges->waycache.at(way->id)->polygon = way->polygon;
                    } else {
                        osmchanges->waycache.at(way->id)->linestring = way->linestring;
                    }
                } else {
                    osmchanges->waycache.insert(std::make_pair(way->id, std::make_shared<osmobjects::OsmWay>(*way)));
                }
            }

        }
    }

    // Build list of Relations that have missing geometries. This list will be used for
    // querying the database and get the geometries of the referenced Ways .
    std::string relsForWayCacheIds;
    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto rel_it = std::begin(change->relations); rel_it != std::end(change->relations); ++rel_it) {
            OsmRelation *relation = rel_it->get();
            if (relation->action != osmobjects::remove) {
                for (auto mit = relation->members.begin(); mit != relation->members.end(); ++mit) {
                    if (mit->type == osmobjects::way && !osmchanges->waycache.count(mit->ref)) {
                        relsForWayCacheIds += std::to_string(mit->ref) + ",";
                    }
                }
            }
        }
    }
    // Get the geometries of the referenced Ways from the DB.
    if (relsForWayCacheIds != "") {
        relsForWayCacheIds.erase(relsForWayCacheIds.size() - 1);
        getWaysByIds(relsForWayCacheIds, osmchanges->waycache);
    }

    // Build geometries for Relations (Polygon or MultiLinestring)
    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto rel_it = std::begin(change->relations); rel_it != std::end(change->relations); ++rel_it) {
            OsmRelation *relation = rel_it->get();
            // Skip removed relations
            if (relation->action != osmobjects::remove) {
                osmchanges->buildRelationGeometry(*relation);
            }
        }
    }
}

// Fill Node cache with Nodes referenced from Ways
void
QueryRaw::getNodeCacheFromWays(std::shared_ptr<std::vector<OsmWay>> ways, std::map<double, point_t> &nodecache) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getNodeCacheFromWays(ways, nodecache): took %w seconds\n");
#endif

    // Build a string list of all Nodes ids referenced from Ways
    std::string nodeIds;
    for (auto wit = ways->begin(); wit != ways->end(); ++wit) {
        for (auto rit = std::begin(wit->refs); rit != std::end(wit->refs); ++rit) {
            nodeIds += std::to_string(*rit) + ",";
        }
    }

    if (nodeIds.size() > 1) {
        nodeIds.erase(nodeIds.size() - 1);

        // Get Nodes geometries from the DB
        std::string nodesQuery = "SELECT osm_id, st_x(geom) as lat, st_y(geom) as lon FROM nodes where osm_id in (" + nodeIds + ") and st_x(geom) is not null and st_y(geom) is not null;";
        auto result = dbconn->query(nodesQuery);
        if (result.size() == 0) {
            log_debug("No results returned!");
            return;
        }

        // Fill nodecache with Nodes geometries (Points)
        for (auto node_it = result.begin(); node_it != result.end(); ++node_it) {
            auto node_id = (*node_it)[0].as<long>();
            auto node_lat = (*node_it)[1].as<double>();
            auto node_lon = (*node_it)[2].as<double>();
            auto point = point_t(node_lat, node_lon);
            nodecache.insert(std::make_pair(node_id, point));
        }
    }
}

// Recieve a string of comma separated values of Nodes ids
// and return a vector of Ways
std::list<std::shared_ptr<OsmWay>>
QueryRaw::getWaysByNodesRefs(std::string &nodeIds) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getWaysByNodesRefs(nodeIds): took %w seconds\n");
#endif
    std::list<std::shared_ptr<osmobjects::OsmWay>> ways;
    std::vector<std::string> queries;

    // Get all Ways that have references to Nodes from the DB, including Polygons and LineString geometries
    // std::string waysQuery = "SELECT distinct(osm_id), refs, version, tags, uid, changeset from way_refs join ways_poly wp on wp.osm_id = way_id where node_id = any(ARRAY[" + nodeIds + "])";
    queries.push_back("SELECT distinct(osm_id), refs, version, tags, uid, changeset from ways_poly where refs @> '{" + nodeIds + "}';");
    queries.push_back("SELECT distinct(osm_id), refs, version, tags, uid, changeset from ways_line where refs @> '{" + nodeIds + "}';");

    for (auto it = queries.begin(); it != queries.end(); ++it) {

        auto ways_result = dbconn->query(*it);
        if (ways_result.size() == 0) {
            log_debug("No results returned!");
            return ways;
        }

        // Create Ways objects and fill the vector
        for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
            auto way = std::make_shared<OsmWay>();
            way->id = (*way_it)[0].as<long>();
            std::string refs_str = (*way_it)[1].as<std::string>();
            if (refs_str.size() > 1) {
                way->refs = arrayStrToVector(refs_str);
            }
            way->version = (*way_it)[2].as<long>();
            auto tags = (*way_it)[3];
            if (!tags.is_null()) {
                auto tags = parseJSONObjectStr((*way_it)[3].as<std::string>());
                for (auto const& [key, val] : tags) {
                    way->addTag(key, val);
                }
            }
            auto uid = (*way_it)[4];
            if (!uid.is_null()) {
                way->uid = (*way_it)[4].as<long>();
            }
            auto changeset = (*way_it)[5];
            if (!changeset.is_null()) {
                way->changeset = (*way_it)[5].as<long>();
            }
            ways.push_back(way);
        }
    }
    return ways;
}

// Get the count of objects for a table (nodes, ways_poly, ways_line, relations)
int QueryRaw::getCount(const std::string &tableName) {
    std::string query = "select count(osm_id) from " + tableName;
    auto result = dbconn->query(query);
    return result[0][0].as<int>();
}

// Get a page of Nodes from the DB, using an id for sorting
// and a page size. This is useful for batch processing of Nodes,
// like the Bootstraping process.
std::shared_ptr<std::vector<OsmNode>>
QueryRaw::getNodesFromDB(long lastid, int pageSize) {
    std::string nodesQuery = "SELECT osm_id, ST_AsText(geom, 4326)";

    if (lastid > 0) {
        nodesQuery += ", version, tags FROM nodes where osm_id < " + std::to_string(lastid) + " order by osm_id desc limit " + std::to_string(pageSize) + ";";
    } else {
        nodesQuery += ", version, tags FROM nodes order by osm_id desc limit " + std::to_string(pageSize) + ";";
    }
    auto nodes = std::make_shared<std::vector<OsmNode>>();
    auto nodes_result = dbconn->query(nodesQuery);
    if (nodes_result.size() == 0) {
        log_debug("No results returned!");
        return nodes;
    }

    // Fill vector of OsmNode objects
    for (auto node_it = nodes_result.begin(); node_it != nodes_result.end(); ++node_it) {
        OsmNode node;
        node.id = (*node_it)[0].as<long>();

        point_t point;
        std::string point_str = (*node_it)[1].as<std::string>();
        bg::read_wkt(point_str, point);
        node.setPoint(bg::get<0>(point), bg::get<1>(point));
        node.version = (*node_it)[2].as<long>();
        auto tags = (*node_it)[3];
        if (!tags.is_null()) {
            auto tags = parseJSONObjectStr((*node_it)[3].as<std::string>());
            for (auto const& [key, val] : tags)
            {
                node.addTag(key, val);
            }
        }
        nodes->push_back(node);
    }

    return nodes;
}


// Get a page of Ways from the DB, using an id for sorting
// and a page size. This is useful for batch processing of Ways,
// like the Bootstraping process.
std::shared_ptr<std::vector<OsmWay>>
QueryRaw::getWaysFromDB(long lastid, int pageSize, const std::string &tableName) {
    std::string waysQuery;
    if (tableName == QueryRaw::polyTable) {
        waysQuery = "SELECT osm_id, refs, ST_AsText(ST_ExteriorRing(geom), 4326)";
    } else {
        waysQuery = "SELECT osm_id, refs, ST_AsText(geom, 4326)";
    }
    if (lastid > 0) {
        waysQuery += ", version, tags FROM " + tableName + " where osm_id < " + std::to_string(lastid) + " order by osm_id desc limit " + std::to_string(pageSize) + ";";
    } else {
        waysQuery += ", version, tags FROM " + tableName + " order by osm_id desc limit " + std::to_string(pageSize) + ";";
    }

    auto ways = std::make_shared<std::vector<OsmWay>>();
    auto ways_result = dbconn->query(waysQuery);
    if (ways_result.size() == 0) {
        log_debug("No results returned!");
        return ways;
    }

    // Fill vector of OsmWay objects
    for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
        OsmWay way;
        way.id = (*way_it)[0].as<long>();
        std::string refs_str = (*way_it)[1].as<std::string>();
        if (refs_str.size() > 1) {
            way.refs = arrayStrToVector(refs_str);

            std::string poly = (*way_it)[2].as<std::string>();
            bg::read_wkt(poly, way.linestring);

            if (tableName == QueryRaw::polyTable) {
                way.polygon = { {std::begin(way.linestring), std::end(way.linestring)} };
            }
            way.version = (*way_it)[3].as<long>();
            auto tags = (*way_it)[4];
            if (!tags.is_null()) {
                auto tags = parseJSONObjectStr((*way_it)[4].as<std::string>());
                for (auto const& [key, val] : tags)
                {
                    way.addTag(key, val);
                }
            }
            ways->push_back(way);
        }
    }

    return ways;
}

// Get a page of Ways from the DB, using an id for sorting
// and a page size, but without using Refs. This is useful 
// for batch processing of Ways that are not from OSM, like
// third party geospatial databases.
std::shared_ptr<std::vector<OsmWay>>
QueryRaw::getWaysFromDBWithoutRefs(long lastid, int pageSize, const std::string &tableName) {
    std::string waysQuery;
    if (tableName == QueryRaw::polyTable) {
        waysQuery = "SELECT osm_id, ST_AsText(ST_ExteriorRing(geom), 4326)";
    } else {
        waysQuery = "SELECT osm_id, ST_AsText(geom, 4326)";
    }
    if (lastid > 0) {
        waysQuery += ", tags FROM " + tableName + " where osm_id < " + std::to_string(lastid) + " order by osm_id desc limit " + std::to_string(pageSize) + ";";
    } else {
        waysQuery += ", tags FROM " + tableName + " order by osm_id desc limit " + std::to_string(pageSize) + ";";
    }

    auto ways = std::make_shared<std::vector<OsmWay>>();
    auto ways_result = dbconn->query(waysQuery);
    if (ways_result.size() == 0) {
        log_debug("No results returned!");
        return ways;
    }

    // Fill vector of OsmWay objects
    for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
        OsmWay way;
        way.id = (*way_it)[0].as<long>();

        std::string poly = (*way_it)[1].as<std::string>();
        bg::read_wkt(poly, way.linestring);

        if (tableName == QueryRaw::polyTable) {
            way.polygon = { {std::begin(way.linestring), std::end(way.linestring)} };
        }
        auto tags = (*way_it)[2];
        if (!tags.is_null()) {
            auto tags = parseJSONObjectStr((*way_it)[2].as<std::string>());
            for (auto const& [key, val] : tags)
            {
                way.addTag(key, val);
            }
        }
        ways->push_back(way);

    }

    return ways;
}


// Get a page of Relations from the DB, using an id for sorting
// and a page size. This is useful for batch processing of Relations,
// like the Bootstraping process.
std::shared_ptr<std::vector<OsmRelation>>
QueryRaw::getRelationsFromDB(long lastid, int pageSize) {
    std::string relationsQuery = "SELECT osm_id, refs, ST_AsText(geom, 4326)";
    if (lastid > 0) {
        relationsQuery += ", version, tags FROM relations where osm_id < " + std::to_string(lastid) + " order by osm_id desc limit " + std::to_string(pageSize) + ";";
    } else {
        relationsQuery += ", version, tags FROM relations order by osm_id desc limit " + std::to_string(pageSize) + ";";
    }

    auto relations = std::make_shared<std::vector<OsmRelation>>();
    auto relations_result = dbconn->query(relationsQuery);
    if (relations_result.size() == 0) {
        log_debug("No results returned!");
        return relations;
    }
    // Fill vector of OsmRelation objects
    for (auto rel_it = relations_result.begin(); rel_it != relations_result.end(); ++rel_it) {
        OsmRelation relation;
        relation.id = (*rel_it)[0].as<long>();
        auto refs = (*rel_it)[1];
        if (!refs.is_null()) {
            auto refs = parseJSONArrayStr((*rel_it)[1].as<std::string>());
            for (auto ref_it = refs.begin(); ref_it != refs.end(); ++ref_it) {
                auto relType = osmobjects::osmtype_t::way;
                if (ref_it->at("type") == "n") {
                    relType = osmobjects::osmtype_t::node;
                } else if (ref_it->at("type") == "r") {
                    relType = osmobjects::osmtype_t::relation;
                }
                relation.addMember(
                    std::stol(ref_it->at("ref")),
                    relType,
                    ref_it->at("role")
                );
            }
            std::string geometry = (*rel_it)[2].as<std::string>();
            if (geometry.substr(0, 7) == "POLYGON") {
                bg::read_wkt(geometry, relation.multipolygon);
            } else if (geometry.substr(0, 15) == "MULTILINESTRING") {
                bg::read_wkt(geometry, relation.multilinestring);
            }
            relation.version = (*rel_it)[3].as<long>();
        }
        auto tags = (*rel_it)[4];
        if (!tags.is_null()) {
            auto tags = parseJSONObjectStr((*rel_it)[4].as<std::string>());
            for (auto const& [key, val] : tags)
            {
                relation.addTag(key, val);
            }
        }
        relations->push_back(relation);
    }

    return relations;
}

} // namespace queryraw

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
