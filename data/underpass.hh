//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

#ifndef __UNDERPASS_HH__
#define __UNDERPASS_HH__

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <future>
#include <iostream>
#include <pqxx/pqxx>
#include <string>
#include <vector>

#include <condition_variable>
#include <mutex>
#include <thread>

#include "boost/date_time/posix_time/posix_time.hpp"
#include <boost/date_time.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;

#include <boost/asio/connect.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl/error.hpp>
#include <boost/asio/ssl/stream.hpp>
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/http/parser.hpp>
#include <boost/beast/version.hpp>

namespace beast = boost::beast;
namespace net = boost::asio;
namespace ssl = boost::asio::ssl;
namespace http = beast::http;
using tcp = net::ip::tcp;

#include "data/pq.hh"
#include "osmstats/osmstats.hh"
#include "osmstats/replication.hh"

namespace replication {
class StateFile;
};

/// \file underpass.hh
/// \brief Underpass for monitoring the OSM planet server for replication files.
///
/// These are the underpass used to download and apply the replication files
/// to a database. The monitor the OSM planet server for updated replication
/// files.

/// \namespace underpass
namespace underpass {

class Underpass : public pq::Pq
{
  public:
    /// Connect to the Underpass database
    Underpass(void)
    {
        frequency_tags[replication::minutely] = "minute";
        frequency_tags[replication::hourly] = "hour";
        frequency_tags[replication::daily] = "day";
        frequency_tags[replication::changeset] = "changeset";
    };
    Underpass(const std::string &dburl);
    void dump(void);

    /// Update the creator table to track editor statistics
    bool updateCreator(long user_id, long change_id, const std::string &editor);

    /// Write the stored data on the directories and timestamps
    /// on the planet server.
    bool writeState(replication::StateFile &state);

    /// Get the state.txt file data by it's path
    std::shared_ptr<replication::StateFile>
    getState(replication::frequency_t freq, const std::string &path);

    /// Get the state.txt date by timestamp
    std::shared_ptr<replication::StateFile>
    getState(replication::frequency_t freq, ptime &tstamp);

    /// Get the maximum timestamp for the state.txt data
    std::shared_ptr<replication::StateFile>
    getLastState(replication::frequency_t freq);

    /// Get the minimum timestamp for the state.txt data
    std::shared_ptr<replication::StateFile>
    getFirstState(replication::frequency_t freq);

    std::shared_ptr<osmstats::RawCountry>
    getCountry(double max_lat, double max_lon, double min_lat, double min_lon);

    std::string parsePath(const std::string &url)
    {
        // return url.substr();
        // FIXME: this needs to parse a full URL, and return the file path
        return url;
    };

    std::string freq_to_string(replication::frequency_t tag)
    {
        return frequency_tags[tag];
    };
    // protected:
    std::map<replication::frequency_t, std::string> frequency_tags;
    std::string db_url;
};

} // namespace underpass

#endif // EOF __UNDERPASS_HH__
