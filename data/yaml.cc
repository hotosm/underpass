//
// Copyright (c) 2020, 2021, 2022 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

/// \file yaml.hh
/// \brief Simple YAML file reader.
///
/// Read in a YAML config file and create a data structure so it can be accessed.

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
# include "unconfig.h"
#endif

#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <boost/algorithm/string.hpp>

#include "yaml.hh"
#include "log.hh"

using namespace logger;

/// \namespace yaml
namespace yaml {

void
Yaml::read(const std::string &fspec)
{
    std::ifstream yaml;
    std::string line;
    std::string::size_type pos1, pos2;
    std::string key;
    std::string value;
    std::vector<std::string> entries;
    bool params = false;

    filespec = fspec;

    try {
        yaml.open(filespec,  std::ifstream::in);
        log_debug(_("Opened %1%"), filespec);
    } catch(std::exception& e) {
        log_error(_("Couildn't open %1% %2%"), filespec, e.what());
        return;
    }
        
    while (getline(yaml, line)) {
	// A top level tag for config parameters
	// Trim all spaces that start the string,
	boost::algorithm::trim_left(line);
	// Ignore blank lines
	if (line.empty()) {
	    continue;
	}
	// Ignore comments
        if (line.front() == '#') {
            continue;
        }
	// If a line doesn't start with a hypen, but has a colon
	// at the end, it's a top level keyword.
	if (line.front() != '-' && line.back() == ':') {
	    line.pop_back();	// delete the colon
	    key = line;
	    entries.clear();
	    if (key == "config") {
		params = true;
	    }
	    if (key == "tags") {
		params = false;
	    }
	    continue;
	} else if (line.front() == '-' && line.back() == ':') {
	    line.erase(0,2);	// delete leading hypen
	    line.pop_back();	// delete the colon
	    key = line;
	    continue;
	// If a line starts with a hypen, and has a colon
	// at the end, it's a 2nd level keyword.
	} else if (line.front() != '-' && line.back() == ':') {
	    line.erase(0,2);	// delete leading hypen
	    line.pop_back();	// delete the colon
	    key = line;
	    entries.push_back(line);
	    continue;
	    // A line starting with a hypen that doesn't have a
	    // a colon us a 2nd level keyword with no values.
	} else if (line.front() == '-' && line.back() != ':') {
	    line.erase(0,2);	// delete leading hypen
	    if (key == "tags") {
		key = line;
	    } else {
		entries.push_back(line);
	    }
	}
	if (params) {
	    config[key] = line;
	} else {
	    tags[key] = entries;
	}
    }
}

void Yaml::dump(void)
{
    std::cerr << std::endl << "Dumping yaml file: " << filespec << std::endl;
    
    for (auto cit = std::begin(config); cit != std::end(config); ++cit) {
	std::cerr << "\tParameter: " << cit->first
		  << " = " << cit->second << std::endl;
    }
    for (auto cit = std::begin(tags); cit != std::end(tags); ++cit) {
	std::cerr << "\tKey: " << cit->first << std::endl;
        if ( cit->second.size() == 0) {
            continue;
        }
        std::vector<std::string> value = cit->second;
        std::cerr << "\t\tValues: ";
        for (auto vit = std::begin(value); vit != std::end(value); ++vit) {
            std::cerr << *vit << ", ";
        }
        std::cerr << std::endl;
    }
}

} // EOF yaml namespace

// Local Variables:
// mode: C++
// indent-tabs-mode: t
// End:
