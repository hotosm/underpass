//
// Copyright (c) 2020, 2021 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <filesystem>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

#include "boost/date_time/posix_time/posix_time.hpp"
#include <boost/date_time.hpp>
#include <boost/format.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;
//#include <boost/tokenizer.hpp>
#include <boost/filesystem.hpp>

#include "data/underpass.hh"
#include "galaxy/changeset.hh"
#include "galaxy/osmchange.hh"
#include "galaxy/replication.hh"

#include "log.hh"
using namespace logger;

namespace underpass {

std::map<replication::frequency_t, std::string> Underpass::frequency_tags = {
    {replication::minutely, "minute"},
    {replication::hourly, "hour"},
    {replication::daily, "day"},
    {replication::changeset, "changesets"}};

Underpass::Underpass(const std::string &dburl) { connect(dburl); };

Underpass::~Underpass()
{
    // db->disconnect();        // close the database connection
    if (sdb) {
        if (sdb->is_open()) {
            sdb->close(); // close the database connection
        }
    }
}

// Dump internal data to the terminal, used only for debugging
void
Underpass::dump(void)
{
    log_debug(_("Database url: %1%"), db_url);
}

std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, const std::string &path)
{

    std::vector<std::string> nodes;
    std::string cleaned_path;
    boost::split(nodes, path, boost::is_any_of("/"));
    if (nodes[0] == "https:") {
        cleaned_path = nodes[5] + "/" + nodes[6] + "/" + nodes[7];
    } else {
        cleaned_path = path;
    }
    //db_mutex.lock();
    const std::string where = "path='" + cleaned_path + "' AND frequency='" +
                              freq_to_string(freq) + "'";
    return stateFromQuery(where);
}

// Get the state.txt date by timestamp
std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, ptime &tstamp)
{

    if (tstamp == boost::posix_time::not_a_date_time) {
        log_error(_("ERROR: bad timestamp!"));
        return std::make_shared<replication::StateFile>();
    }

    // FIXME: freq is not necessarily minutes
    const ptime other = tstamp + minutes(1);

    const std::string where{boost::str(
        format("timestamp BETWEEN '%1%' AND '%2%' AND frequency = '%3%'") %
        to_iso_extended_string(tstamp) % to_iso_extended_string(other) %
        freq_to_string(freq))};
    const std::string order_by{"timestamp ASC"};
    return stateFromQuery(where, order_by);
}

std::shared_ptr<replication::StateFile>
Underpass::getState(replication::frequency_t freq, long sequence)
{
    return stateFromQuery("frequency = '" + freq_to_string(freq) + "' AND " +
                          "sequence=" + std::to_string(sequence));
}

std::shared_ptr<replication::StateFile>
Underpass::getStateGreaterThan(replication::frequency_t freq, long sequence)
{
    return stateFromQuery("frequency='" + freq_to_string(freq) + "' AND " +
                              "sequence > " + std::to_string(sequence),
                          "sequence ASC");
}

std::shared_ptr<replication::StateFile>
Underpass::getStateGreaterThan(replication::frequency_t freq, ptime &timestamp)
{
    if (timestamp == boost::posix_time::not_a_date_time) {
        log_error(_("ERROR: bad timestamp!"));
        return std::make_shared<replication::StateFile>();
    }
    return stateFromQuery("frequency='" + freq_to_string(freq) + "' AND " +
                              " timestamp > '" +
                              to_iso_extended_string(timestamp) + "'",
                          "timestamp ASC");
}

std::shared_ptr<replication::StateFile>
Underpass::getStateLessThan(replication::frequency_t freq, long sequence)
{
    return stateFromQuery("frequency='" + freq_to_string(freq) + "' AND " +
                              "sequence > " + std::to_string(sequence),
                          "sequence DESC");
}

std::shared_ptr<replication::StateFile>
Underpass::getStateLessThan(replication::frequency_t freq, ptime &timestamp)
{
    if (timestamp == boost::posix_time::not_a_date_time) {
        log_error(_("Bad timestamp!"));
        return std::make_shared<replication::StateFile>();
    }
    return stateFromQuery("frequency='" + freq_to_string(freq) + "' AND " +
                              "timestamp < '" +
                              to_iso_extended_string(timestamp) + '\'',
                          "timestamp DESC");
}

/// Write the stored data on the directories and timestamps
/// on the planet server.
bool
Underpass::writeState(replication::StateFile &state)
{

    // Precondition
    assert(state.isValid());

    std::string query;
    pqxx::work worker(*sdb);

    if (state.created_at != boost::posix_time::not_a_date_time) {
        query = "INSERT INTO states(timestamp, sequence, path, frequency, "
                "created_at, closed_at) VALUES(";
    } else {
        query =
            "INSERT INTO states(timestamp, sequence, path, frequency) VALUES(";
    }
    query += "\'" + to_iso_extended_string(state.timestamp) + "\',";
    query += std::to_string(state.sequence);
    std::vector<std::string> nodes;
    boost::split(nodes, state.path, boost::is_any_of("/"));
    std::string tmp;
    if (nodes[0] == "https:") {
        tmp = nodes[5] + '/' + nodes[6] + '/' + nodes[7];
    } else {
        tmp = state.path;
    }

    query += ",\'" + tmp + "\'";

    // Deduce the frequency from the path is it's not explicitly set
    std::string frequency{state.frequency};
    if (frequency.empty()) {

        if (state.path.find("changesets") != std::string::npos) {
            frequency = Underpass::freq_to_string(replication::changeset);
        } else if (state.path.find("minute") != std::string::npos) {
            frequency = Underpass::freq_to_string(replication::minutely);
        } else if (state.path.find("hour") != std::string::npos) {
            frequency = Underpass::freq_to_string(replication::hourly);
        } else if (state.path.find("day") != std::string::npos) {
            frequency = Underpass::freq_to_string(replication::daily);
        }
    }

    query += ", " + worker.quote(frequency);

    if (state.created_at != boost::posix_time::not_a_date_time) {
        query += ", \'" + to_simple_string(state.created_at) + "\'";
        query += ", \'" + to_simple_string(state.closed_at) + "\'";
    }
    query += ") ON CONFLICT DO NOTHING;";
    log_debug(query);
    //db_mutex.lock();
    try {
        const auto result = worker.exec(query);
        worker.commit();
    } catch (pqxx::sql_error const &ex) {
        log_error(_("Error storing state in the DB: %1%"), ex.what());
        return false;
    }
    return true;
}

/// Get the maximum timestamp for the state.txt data
std::shared_ptr<replication::StateFile>
Underpass::getLastState(replication::frequency_t freq)
{
    return stateFromQuery("frequency='" + freq_to_string(freq) + "'",
                          "timestamp DESC");
}

// Get the minimum timestamp for the state.txt data. As hashtags didn't
// appear until late 2014, we don't care as much about the older data.
std::shared_ptr<replication::StateFile>
Underpass::getFirstState(replication::frequency_t freq)
{
    return stateFromQuery("frequency='" + freq_to_string(freq) + "'",
                          "timestamp ASC");
}

std::shared_ptr<replication::StateFile>
Underpass::stateFromQuery(const std::string &where, const std::string &order_by)
{
    // Precondition
    assert(sdb);

    auto state = std::make_shared<replication::StateFile>();

    pqxx::work worker(*sdb);
    std::string query =
        "SELECT frequency,timestamp,sequence,path,created_at,closed_at FROM "
        "states";
    if (!where.empty()) {
        query += " WHERE " + where;
    }

    if (!order_by.empty()) {
        query += " ORDER BY " + order_by;
    }

    query += " LIMIT 1;";
    log_debug(_("QUERY: %1%"), query);
    try {
        pqxx::result result = worker.exec(query);
        if (result.size() > 0) {
            state->frequency = pqxx::to_string(result[0][0]);
            state->timestamp = time_from_string(pqxx::to_string(result[0][1]));
            state->sequence = result[0][2].as(int(0));
            state->path = pqxx::to_string(result[0][3]);
            auto datetime_str{pqxx::to_string(result[0][4])};
            if (!datetime_str.empty()) {
                state->created_at = time_from_string(datetime_str);
            }
            datetime_str = pqxx::to_string(result[0][5]);
            if (!datetime_str.empty()) {
                state->closed_at = time_from_string(datetime_str);
            }
        } else {
            log_debug(_("Returning invalid state: no rows from query - %1%"),
                      query);
        }
        worker.commit();
    } catch (std::exception const &e) {
        log_error(_("Error quering states table: %1%"), e.what());
    }
    return state;
}

} // namespace underpass

// local Variables:
// mode: C++
// indent-tabs-mode: t
// End:
