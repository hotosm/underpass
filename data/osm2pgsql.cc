//
// Copyright (c) 2020, 2021, 2022 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <chrono>
#include <string>
#include <regex>
#include <cmath>

#include <pqxx/nontransaction>

#include <boost/iostreams/copy.hpp>
#include <boost/process.hpp>
using namespace boost::process;
#include <boost/format.hpp>
using boost::format;

#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/timer/timer.hpp>

#include "osm2pgsql.hh"
#include "data/osmobjects.hh"
using namespace osmobjects;

#include "log.hh"
using namespace logger;

namespace osm2pgsql {

const std::string Osm2Pgsql::OSM2PGSQL_DEFAULT_SCHEMA_NAME = "public";

logger::LogFile &dbglogfile = logger::LogFile::getDefaultInstance();

const std::regex Osm2Pgsql::TagParser::tags_escape_re = std::regex(R"re(("))re");

// clang-format off
const std::set<std::string> Osm2Pgsql::TagParser::polygon_tags = {
    "aeroway",
    "amenity",
    "building",
    "harbour",
    "historic",
    "landuse",
    "leisure",
    "man_made",
    "military",
    "natural",
    "office",
    "place",
    "power",
    "public_transport",
    "shop",
    "sport",
    "tourism",
    "water",
    "waterway",
    "wetland"
};

// Process tags, this is the list of tag names that map to all table columns
const std::set<std::string> Osm2Pgsql::TagParser::column_stored_tags = {
    "access",
    "addr:housename",
    "addr:housenumber",
    "addr:interpolation",
    "admin_level",
    "aerialway",
    "aeroway",
    "amenity",
    "area",
    "barrier",
    "bicycle",
    "brand",
    "bridge",
    "boundary",
    "building",
    "construction",
    "covered",
    "culvert",
    "cutting",
    "denomination",
    "disused",
    "embankment",
    "foot",
    "generator:source",
    "harbour",
    "highway",
    "historic",
    "horse",
    "intermittent",
    "junction",
    "landuse",
    "layer",
    "leisure",
    "lock",
    "man_made",
    "military",
    "motorcar",
    "name",
    "natural",
    "office",
    "oneway",
    "operator",
    "place",
    "population",
    "power",
    "power_source",
    "public_transport",
    "railway",
    "ref",
    "religion",
    "route",
    "service",
    "shop",
    "sport",
    "surface",
    "toll",
    "tourism",
    "tower:type",
    "tunnel",
    "water",
    "waterway",
    "wetland",
    "width",
    "wood"
};

// Process tags, this is the list of additional tag names that map to points table columns only
const std::set<std::string> Osm2Pgsql::TagParser::column_points_stored_tags = {
    "capital",  // Points only
    "ele", // Points only
};


const std::set<std::string> Osm2Pgsql::TagParser::generic_keys = {
    "access",
    "addr:housename",
    "addr:housenumber",
    "addr:interpolation",
    "admin_level",
    "aerialway",
    "aeroway",
    "amenity",
    "area",
    "barrier",
    "bicycle",
    "boundary",
    "brand",
    "bridge",
    "building",
    "capital",
    "construction",
    "covered",
    "culvert",
    "cutting",
    "denomination",
    "disused",
    "ele",
    "embarkment",
    "foot",
    "generation:source",
    "harbour",
    "highway",
    "historic",
    "hours",
    "intermittent",
    "junction",
    "landuse",
    "layer",
    "leisure",
    "lock",
    "man_made",
    "military",
    "motor_car",
    "name",
    "natural",
    "office",
    "oneway",
    "operator",
    "place",
    "population",
    "power",
    "power_source",
    "public_transport",
    "railway",
    "ref",
    "religion",
    "route",
    "service",
    "shop",
    "sport",
    "surface",
    "toll",
    "tourism",
    "tower:type",
    "tracktype",
    "tunnel",
    "type",
    "water",
    "waterway",
    "wetland",
    "width",
    "wood"
};

const std::map<std::pair<std::string, std::string>, std::pair<bool, int>> Osm2Pgsql::TagParser::z_index_map = {
    {{"railway", ""}, {5, 1}},
    {{"boundary", "administrative "}, {0, 1}},
    {{"bridge", "yes"}, {10, 0}},
    {{"bridge", "true"}, {10, 0}},
    {{"bridge", "1"}, {10, 0}},
    {{"tunnel", "yes"}, {-10, 0}},
    {{"tunnel", "true"}, {-10, 0}},
    {{"tunnel", "1"}, {-10, 0}},
    {{"highway", "minor"}, {3, 0}},
    {{"highway", "road"}, {3, 0}},
    {{"highway", "unclassified"}, {3, 0}},
    {{"highway", "residential"}, {3, 0}},
    {{"highway", "tertiary_link"}, {4, 0}},
    {{"highway", "tertiary"}, {4, 0}},
    {{"highway", "secondary_link"}, {6, 1}},
    {{"highway", "secondary"}, {6, 1}},
    {{"highway", "primary_link"}, {7, 1}},
    {{"highway", "primary"}, {7, 1}},
    {{"highway", "trunk_link"}, {8, 1}},
    {{"highway", "trunk"}, {8, 1}},
    {{"highway", "motorway_link"}, {9, 1}},
    {{"highway", "motorway"}, {9, 1}}
};

// clang-format on

Osm2Pgsql::Osm2Pgsql(const std::string &_dburl, const std::string &schema) : pq::Pq(), schema(schema)
{
    if (!connect(_dburl)) {
        log_error(_("Could not connect to osm2pgsql server %1%"), _dburl);
    }
}

ptime
Osm2Pgsql::getLastUpdate()
{
    if (last_update.is_not_a_date_time()) {
        getLastUpdateFromDb();
    }
    return last_update;
}

#if 0

// osm2pgsql fork is disabled but left in the sources because it may be useful to
// compare the results of the original application with those of our clone
// implementation.

bool
Osm2Pgsql::updateDatabase(const std::string &osm_changes)
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("Osm2Pgsql::updateDatabase: took %w seconds\n");
#endif
    // -l for 4326
    std::string osm2pgsql_update_command{
        "osm2pgsql -l --append -r xml -s -C 300 -G --hstore-all --extra-attributes --middle-schema=" + schema +
        " --output-pgsql-schema=" + schema + " -d postgresql://"};
    // Append DB url in the form: postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&...]
    osm2pgsql_update_command.append(dburl);
    // Read from stdin
    osm2pgsql_update_command.append(" -");

    log_debug(_("Executing osm2pgsql, command: %1%"), osm2pgsql_update_command);

    ipstream out;
    ipstream err;
    opstream in;

    child osm2pgsql_update_process(osm2pgsql_update_command, std_out > out, std_err > err, std_in < in);

    in.write(osm_changes.data(), osm_changes.size());
    in.close();
    in.pipe().close();

    // FIXME: make wait_for duration an arg
    bool result{(!osm2pgsql_update_process.running() || osm2pgsql_update_process.wait_for(std::chrono::minutes{1})) &&
                osm2pgsql_update_process.exit_code() == EXIT_SUCCESS};
    if (!result) {
        std::stringstream err_mesg;
        boost::iostreams::copy(err, err_mesg);
        log_error(_("Error running osm2pgsql command %1%\n%2%"), osm2pgsql_update_command, err_mesg.str());
    }
    return result;
}
#endif

bool
Osm2Pgsql::updateDatabase(const std::shared_ptr<OsmChangeFile> &osm_changes) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("Osm2Pgsql::updateDatabase: took %w seconds\n");
#endif
    // Preconditions
    assert(static_cast<bool>(osm_changes));

    if (!isOpen()) {
        log_error(_("Could not update osm2pgsql DB %1%: DB is closed!"), dburl);
        return false;
    }

    for (const auto &change: std::as_const(osm_changes->changes)) {
        switch (change->action) {
            case action_t::modify:
            case action_t::create:
            {
                for (const auto &node: std::as_const(change->nodes)) {
                    upsertNode(node);
                }
                for (const auto &way: std::as_const(change->ways)) {
                    upsertWay(way);
                }
                for (const auto &relation: std::as_const(change->relations)) {
                    upsertRelation(relation);
                }
                break;
            }
            case action_t::remove:
            {
                for (const auto &node: std::as_const(change->nodes)) {
                    removeNode(node);
                }
                for (const auto &way: std::as_const(change->ways)) {
                    removeWay(way);
                }
                for (const auto &relation: std::as_const(change->relations)) {
                    removeRelation(relation);
                }
                break;
            }
            case action_t::none:
            {
                break;
            }
        }
    }

    return true;
}

bool
Osm2Pgsql::upsertWay(const std::shared_ptr<osmobjects::OsmWay> &way) const
{
    // Preconditions
    assert(static_cast<bool>(sdb));

    std::list<std::shared_ptr<osmobjects::OsmRelation>> relations_to_update;

    TagParser parser;
    {
        pqxx::nontransaction worker(*sdb);
        auto tags{way->tags};
        tags.emplace("osm_version", std::to_string(way->version));
        tags.emplace("osm_changeset", std::to_string(way->change_id));
        tags.emplace("osm_timestamp", to_iso_extended_string(way->timestamp) + "Z");
        parser.parse(tags, worker, false);
    }

    std::string refs{"'{"};
    bool is_first{true};
    for (const auto &ref: std::as_const(way->refs)) {
        if (is_first) {
            is_first = false;
        } else {
            refs.append(",");
        }
        refs.append(std::to_string(ref));
    }
    refs.append("}'");

    // First: upsert in middle table
    const std::string middle_sql{str(format(R"sql(
      INSERT INTO %1%.planet_osm_ways
        (id, nodes, tags)
        VALUES ($1, %2%, %3%)
      ON CONFLICT (id) DO
        UPDATE
        SET nodes = %2%, tags = %3%
        WHERE %1%.planet_osm_ways.id = $1
      )sql") % schema % refs % parser.tags_array_literal)};

    // No upsert here because planet_osm_roads/line have no PK ...
    const std::string delete_roads_sql{str(format("DELETE FROM %1%.planet_osm_roads WHERE osm_id = $1") % schema)};
    const std::string delete_line_sql{str(format("DELETE FROM %1%.planet_osm_line WHERE osm_id = $1") % schema)};
    const std::string delete_polygon_sql{str(format("DELETE FROM %1%.planet_osm_polygon WHERE osm_id = $1") % schema)};
    const std::string update_way_area_sql{
        str(format("UPDATE %1%.planet_osm_polygon SET way_area = ST_Area(way) WHERE osm_id = $1") % schema)};

    std::string insert_sql;

    if (parser.is_polygon && !way->isClosed()) {
        // This is not necessarily an error: some tags might be applied to both polygons and linestrings
        log_debug(_("Way %1% is tagged as a possible polygon but it isn't closed! Storing as linestring."), way->id);
    }

    if (parser.is_polygon && way->isClosed()) {
        // Insert
        insert_sql = str(format(R"sql(
          INSERT INTO %1%.planet_osm_%2%
            (osm_id, way, tags %3%)
          VALUES ($1, ST_SetSRID( ST_MakePolygon( ST_MakeLine( ARRAY(
            SELECT ST_MakePoint(n.lon/10000000.0 , n.lat/10000000.0) FROM %1%.planet_osm_nodes n
            JOIN UNNEST(%6%::bigint[]) WITH ORDINALITY t(id, ord) USING (id) ORDER BY t.ord ))), 4326 ),
          %5% %4%)
        )sql") % schema % "polygon" %
                         parser.tag_field_names % parser.tag_field_values % parser.tags_hstore_literal % refs);

    } else {
        // Decide if it's a road or a line
        const std::string way_type{parser.is_road ? "roads" : "line"};

        // Insert
        insert_sql = str(format(R"sql(
          INSERT INTO %1%.planet_osm_%2%
            (osm_id, way, tags %3%)
          VALUES ($1, ST_SetSRID( ST_MakeLine( ARRAY(
            SELECT ST_MakePoint(n.lon/10000000.0 , n.lat/10000000.0) FROM %1%.planet_osm_nodes n
            JOIN UNNEST(%6%::bigint[]) WITH ORDINALITY t(id, ord) USING (id) ORDER BY t.ord )), 4326 ),
          %5% %4%)
          )sql") % schema %
                         way_type % parser.tag_field_names % parser.tag_field_values % parser.tags_hstore_literal % refs);
    }

    // Scoped worker
    {
        pqxx::nontransaction worker_nt(*sdb);
        //std::cerr << middle_sql << std::endl;
        //std::cerr << insert_sql << std::endl;

        try {
            worker_nt.exec("BEGIN;");
            worker_nt.exec_params0(middle_sql, way->id);
            worker_nt.exec_params0(delete_line_sql, way->id);
            worker_nt.exec_params0(delete_roads_sql, way->id);
            worker_nt.exec_params0(delete_polygon_sql, way->id);
            worker_nt.exec_params0(insert_sql, way->id);

            if (parser.is_polygon && way->isClosed()) {
                worker_nt.exec_params0(update_way_area_sql, way->id);
            }
            worker_nt.exec("COMMIT;");
        } catch (const std::exception &ex) {
            log_error(_("Couldn't upsert way/road record: %1%"), ex.what());
            worker_nt.exec("ROLLBACK;");
            return false;
        }

        // Collect relations that need update
        try {
            worker_nt.exec("BEGIN;");
            const auto relations{worker_nt.exec_params(str(format(R"sql(SELECT * FROM %1%.planet_osm_rels WHERE $1 = ANY(parts[way_off:rel_off]))sql") % schema), way->id)};
            for (const auto &relation: std::as_const(relations)) {
                auto relation_to_update = std::make_shared<osmobjects::OsmRelation>();
                relation_to_update->id = relation["id"].as(long());
                auto members{relation["members"].as_array()};
                std::pair<pqxx::array_parser::juncture, std::string> elem;
                std::string member_id;
                do {
                    elem = members.get_next();
                    if (elem.first == pqxx::array_parser::juncture::string_value) {
                        if (member_id.empty()) {
                            member_id = elem.second;
                        } else {
                            osmobjects::osmtype_t member_type;
                            switch (member_id[0]) {
                                case 'w':
                                    member_type = osmobjects::osmtype_t::way;
                                    break;
                                case 'n':
                                    member_type = osmobjects::osmtype_t::node;
                                    break;
                                case 'r':
                                    member_type = osmobjects::osmtype_t::relation;
                                    break;
                            }
                            relation_to_update->addMember(std::stol(member_id.substr(1)), member_type, elem.second);
                            member_id.clear();
                        }
                    }
                } while (elem.first != pqxx::array_parser::juncture::done);

                // Parse tags
                auto tags = relation["tags"].as_array();
                std::string tag_name;
                do {
                    elem = tags.get_next();
                    if (elem.first == pqxx::array_parser::juncture::string_value) {
                        if (tag_name.empty()) {
                            tag_name = elem.second;
                        } else {
                            relation_to_update->addTag(tag_name, elem.second);
                            tag_name.clear();
                        }
                    }
                } while (elem.first != pqxx::array_parser::juncture::done);

                relations_to_update.push_back(relation_to_update);
            }
            worker_nt.exec("COMMIT;");
        } catch (const std::exception &ex) {
            log_error(_("Couldn't update relations after upsert ways record: %1%"), ex.what());
            worker_nt.exec("ROLLBACK;");
        }
    }

    for (const auto &relation: std::as_const(relations_to_update)) {
        upsertRelation(relation);
    }

    return true;
}

bool
Osm2Pgsql::upsertNode(const std::shared_ptr<osmobjects::OsmNode> &node) const
{
    // Preconditions
    assert(static_cast<bool>(sdb));

    std::list<std::shared_ptr<osmobjects::OsmWay>> ways_to_update;

    {

        pqxx::nontransaction worker(*sdb);

        // First: upsert in middle table
        const std::string middle_sql{str(format(R"sql(
        INSERT INTO %1%.planet_osm_nodes
          (id, lon, lat)
          VALUES ($1, $2, $3)
        ON CONFLICT (id) DO
          UPDATE
          SET lon = $2, lat = $3
          WHERE %1%.planet_osm_nodes.id = $1
        )sql") % schema)};

        TagParser parser;
        auto tags{node->tags};
        tags.emplace("osm_version", std::to_string(node->version));
        tags.emplace("osm_changeset", std::to_string(node->change_id));
        tags.emplace("osm_timestamp", to_iso_extended_string(node->timestamp) + "Z");
        parser.parse(tags, worker, true);

        // No upsert here because planet_osm_point has no PK ...
        const std::string delete_sql{str(format(R"sql(DELETE FROM %1%.planet_osm_point WHERE osm_id = $1)sql") % schema)};
        // Insert
        const std::string insert_sql{str(format(R"sql(
        INSERT INTO %1%.planet_osm_point
          (osm_id, way, tags %2%)
          VALUES ($1, public.ST_SetSRID(public.ST_MakePoint($2, $3), 4326), %4% %3%)
        )sql") % schema % parser.tag_field_names %
                                         parser.tag_field_values % parser.tags_hstore_literal)};

        //std::cerr << middle_sql << std::endl;
        //std::cerr << insert_sql << std::endl;

        try {
            worker.exec("BEGIN;");
            worker.exec_params0(middle_sql, node->id, static_cast<int>(std::round(node->point.x() * 10000000)),
                                static_cast<int>(std::round(node->point.y() * 10000000)));
            worker.exec_params0(delete_sql, node->id);
            // Filter out nodes without any generic key
            if (parser.has_generic_key) {
                worker.exec_params0(insert_sql, node->id, node->point.x(), node->point.y());
            }

            worker.exec("COMMIT;");
        } catch (const std::exception &ex) {
            log_error(_("Couldn't upsert node/points record: %1%"), ex.what());
            worker.exec("ROLLBACK;");
            return false;
        }

        // If the node was part of a way we need to update the way as well
        try {
            worker.exec("BEGIN;");
            const auto noded_ways{worker.exec_params(str(format(R"sql(SELECT * FROM %1%.planet_osm_ways WHERE $1 = ANY(nodes))sql") % schema), node->id)};
            for (const auto &way: std::as_const(noded_ways)) {
                auto way_to_update = std::make_shared<osmobjects::OsmWay>(way["id"].as(long()));
                const auto nodes_str{way["nodes"].as(std::string())};
                std::list<std::string> nodes;
                boost::split(nodes, nodes_str.substr(1, nodes_str.size() - 2), [](char c) { return c == ','; });
                for (const auto &node: std::as_const(nodes)) {
                    way_to_update->addRef(std::stol(node));
                }
                // Parse tags
                auto tags = way["tags"].as_array();
                std::pair<pqxx::array_parser::juncture, std::string> elem;
                std::string tag_name;
                do {
                    elem = tags.get_next();
                    if (elem.first == pqxx::array_parser::juncture::string_value) {
                        if (tag_name.empty()) {
                            tag_name = elem.second;
                        } else {
                            way_to_update->addTag(tag_name, elem.second);
                            tag_name.clear();
                        }
                    }
                } while (elem.first != pqxx::array_parser::juncture::done);

                // Now add column tags, we don't know at this point if the way was stored as road, line or polygon
                auto tags_from_stored{worker.exec_params(str(format(R"sql(
              SELECT * FROM %1%.planet_osm_polygon WHERE osm_id = $1
              UNION SELECT * FROM %1%.planet_osm_line WHERE osm_id = $1
              UNION SELECT * FROM %1%.planet_osm_polygon WHERE osm_id = $1  LIMIT 1
              )sql") % schema),
                                                         way["id"].as(long()))};

                if (!tags_from_stored.empty()) {
                    for (const auto &tag_name: std::as_const(Osm2Pgsql::TagParser::column_stored_tags)) {
                        const auto tag_value{tags_from_stored[0][tag_name].as(std::string())};
                        if (!tag_value.empty()) {
                            way_to_update->addTag(tag_name, tag_value);
                        }
                    }
                } else {
                    log_debug(_("Couldn't retrieve tags from stored ways %1% after upsert node/points record"), way["id"].as(long()));
                }
                ways_to_update.push_back(way_to_update);
            }
            worker.exec("COMMIT;");
        } catch (const std::exception &ex) {
            log_error(_("Couldn't update ways after upsert node/points record: %1%"), ex.what());
            worker.exec("ROLLBACK;");
        }
    }

    for (const auto &way: std::as_const(ways_to_update)) {
        upsertWay(way);
    }

    return true;
}

bool
Osm2Pgsql::upsertRelation(const std::shared_ptr<osmobjects::OsmRelation> &relation) const
{

    // Preconditions
    assert(static_cast<bool>(sdb));

    pqxx::nontransaction worker(*sdb);

    TagParser parser;
    auto tags{relation->tags};
    tags.emplace("osm_version", std::to_string(relation->version));
    tags.emplace("osm_changeset", std::to_string(relation->change_id));
    tags.emplace("osm_timestamp", to_iso_extended_string(relation->timestamp) + "Z");
    parser.parse(tags, worker, false);

    // Multipolygons
    const bool is_multi_polygon{relation->tags.find("type") != relation->tags.end() && relation->tags.at("type") == "multipolygon"};

    std::list<Polygon> polygons;

    // First: upsert in middle table
    // The member attribute is an array with IDs, where all node members come first,
    // then all way members, then all relation members, and way_off is the index of the
    // first way member and rel_off the index of the first relation member.
    /*
     Column  |   Type   | Collation | Nullable | Default
    ---------+----------+-----------+----------+---------
     id      | bigint   |           | not null |
     way_off | smallint |           |          |
     rel_off | smallint |           |          |
     parts   | bigint[] |           |          |
     members | text[]   |           |          |
     tags    | text[]   |           |          |
    */

    std::string members{"'{"};
    std::string parts{"'{"};

    // Reorder members
    std::list<const osmobjects::OsmRelationMember *> nodes;
    std::list<const osmobjects::OsmRelationMember *> ways;
    std::list<const osmobjects::OsmRelationMember *> relations;
    std::list<long> way_ids;
    for (const auto &rel: std::as_const(relation->members)) {
        switch (rel.type) {
            case osmobjects::osmtype_t::way:
            {
                ways.push_back(&rel);
                way_ids.push_back(rel.ref);
                break;
            }
            case osmobjects::osmtype_t::node:
            {
                nodes.push_back(&rel);
                break;
            }
            case osmobjects::osmtype_t::relation:
            {
                relations.push_back(&rel);
                break;
            }
            case osmobjects::osmtype_t::empty:
            case osmobjects::osmtype_t::member:
                break;
        }
    };

    int way_off = nodes.size();
    int rel_off = nodes.size() + ways.size();

    // Store information about not-closed ways
    std::map<long, std::pair<long, long>> not_closed_ways;
    if (way_ids.size() > 1) {
        not_closed_ways = notClosedWays(way_ids, worker);
    }

    std::list<const osmobjects::OsmRelationMember *> all_members;
    all_members.insert(all_members.end(), nodes.begin(), nodes.end());
    all_members.insert(all_members.end(), ways.begin(), ways.end());
    all_members.insert(all_members.end(), relations.begin(), relations.end());

    // Keeps track of added outer and inner rings
    std::list<long> rings_added;

    for (const auto &rel: std::as_const(all_members)) {
        if (members.size() > 2) {
            members.push_back(',');
        }
        switch (rel->type) {
            case osmobjects::osmtype_t::way:
            {
                if (std::find(rings_added.begin(), rings_added.end(), rel->ref) == rings_added.end()) {
                    members.append("w" + std::to_string(rel->ref) + ",\"" + rel->role + "\"");
                    if (rel->role == "inner") {
                        // Found in the wild a polygon where inner rings are listed before outer rings
                        // In this case we create a polygon with no outer ring, hoping that we'll get it later
                        if (polygons.size() == 0) {
                            polygons.push_back(Polygon());
                        }
                        if (!polygons.back().inner.empty()) {
                            polygons.back().inner.push_back(',');
                        }
                        polygons.back().inner.append(std::to_string(rel->ref));
                    } else if (rel->role == "outer") {
                        // Handle the case where a polygon with inner rings but without outer ring was created
                        if (polygons.size() > 0 && polygons.back().outer.empty()) {
                            polygons.back().outer.push_back(rel->ref);
                            rings_added.push_back(rel->ref);
                        } else if (polygons.size() == 0) {
                            polygons.push_back(Polygon(rel->ref));
                            rings_added.push_back(rel->ref);
                        } else {
                            // Handle not-closed ways: if the last outer was not closed, add this part
                            if (not_closed_ways.find(polygons.back().outer.back()) != not_closed_ways.end() &&
                                not_closed_ways.find(rel->ref) != not_closed_ways.end()) {
                                polygons.back().outer.push_back(rel->ref);
                                rings_added.push_back(rel->ref);
                            } else {
                                polygons.push_back(Polygon(rel->ref));
                                rings_added.push_back(rel->ref);
                            }
                        }
                    }
                }
                break;
            }
            case osmobjects::osmtype_t::relation:
            {
                members.append("w" + std::to_string(rel->ref) + ",\"" + rel->role + "\"");
                break;
            }
            case osmobjects::osmtype_t::node:
            {
                members.append("w" + std::to_string(rel->ref) + ",\"" + rel->role + "\"");
                break;
            }
            case osmobjects::osmtype_t::empty:
            case osmobjects::osmtype_t::member:
                break;
        }

        // Store part id
        if (rel->type != osmobjects::osmtype_t::empty && rel->type != osmobjects::osmtype_t::member) {
            if (parts.size() > 2) {
                parts.push_back(',');
            }
            parts.append(std::to_string(rel->ref));
        }
    }

    members.append("}'");
    parts.append("}'");

    const std::string middle_sql{str(format(R"sql(
    INSERT INTO %1%.planet_osm_rels
      (id, way_off, rel_off, parts, members, tags)
      VALUES ($1, %2%, %3%, %4%, %5%, %6%)
    ON CONFLICT (id) DO
      UPDATE
      SET
        way_off = %2%,
        rel_off = %3%,
        parts  = %4%,
        members = %5%,
        tags = %6%
      WHERE %1%.planet_osm_rels.id = $1
    )sql") % schema % way_off % rel_off %
                                     parts % members % parser.tags_array_literal)};

    //std::cerr << middle_sql << std::endl;

    try {
        worker.exec("BEGIN;");
        worker.exec_params0(middle_sql, relation->id);
        worker.exec0("DELETE FROM " + schema + ".planet_osm_polygon WHERE osm_id = -" + std::to_string(relation->id));
        std::string multi_polygons_parts_sql;
        if (is_multi_polygon) {
            for (const auto &poly: std::as_const(polygons)) {
                const auto inner_id_sql{poly.inner.empty() ? std::to_string(std::numeric_limits<long>::lowest()) : poly.inner};
                if (poly.outer.empty()) {
                    log_error(_("A polygon with no outer rings is invalid! Skipping relation %1%."), relation->id);
                } else {
                    if (!multi_polygons_parts_sql.empty()) {
                        multi_polygons_parts_sql.append(", ");
                    }

                    // Closed outer polygon
                    if (poly.outer.size() == 1) {
                        multi_polygons_parts_sql.append(str(format(R"sql(
                      (SELECT ST_MakePolygon( ST_SetSRID(ST_MakeLine( ARRAY(
                      SELECT ST_MakePoint(n.lon/10000000.0 , n.lat/10000000.0)
                        FROM %1%.planet_osm_nodes n
                        JOIN UNNEST(w.nodes)
                        WITH ORDINALITY t(id, ord) USING (id) ORDER BY t.ord )), 4326),
                        ARRAY(
                          SELECT ST_exteriorRing(foo.geom) FROM
                            (SELECT (ST_Dump(ST_CollectionExtract(ST_Polygonize(ST_SetSRID(ST_MakeLine( ARRAY(
                              SELECT ST_MakePoint(n_inner.lon/10000000.0 , n_inner.lat/10000000.0)
                                FROM %1%.planet_osm_nodes n_inner
                                JOIN UNNEST(w_inner.nodes)
                                WITH ORDINALITY t(id, ord) USING (id) ORDER BY t.ord )), 4326)), 3))).geom as geom
                                FROM %1%.planet_osm_ways w_inner WHERE w_inner.id IN(%4%)) AS foo
                        ) -- array
                      ) -- mk poly
                      FROM %1%.planet_osm_ways w WHERE w.id = %3%)
                      )sql") % schema % relation->id % poly.outer.back() %
                                                            inner_id_sql));
                    } else {
                        std::string outer_id_sql;
                        for (const auto &outer_id: std::as_const(poly.outer)) {
                            if (!outer_id_sql.empty()) {
                                outer_id_sql.push_back(',');
                            }
                            outer_id_sql.append(std::to_string(outer_id));
                        }
                        multi_polygons_parts_sql.append(str(format(R"sql(
                        (SELECT ST_MakePolygon(ST_ExteriorRing(ST_GeometryN(ST_CollectionExtract(ST_Polygonize(ST_SetSRID(ST_MakeLine( ARRAY(
                        SELECT ST_MakePoint(n.lon/10000000.0 , n.lat/10000000.0)
                          FROM %1%.planet_osm_nodes n
                          JOIN UNNEST(w.nodes)
                          WITH ORDINALITY t(id, ord) USING (id) ORDER BY t.ord )), 4326)), 3), 1)),
                          ARRAY(
                            SELECT ST_exteriorRing(foo.geom) FROM
                              (SELECT (ST_Dump(ST_CollectionExtract(ST_Polygonize(ST_SetSRID(ST_MakeLine( ARRAY(
                                SELECT ST_MakePoint(n_inner.lon/10000000.0 , n_inner.lat/10000000.0)
                                  FROM %1%.planet_osm_nodes n_inner
                                  JOIN UNNEST(w_inner.nodes)
                                  WITH ORDINALITY t(id, ord) USING (id) ORDER BY t.ord )), 4326)), 3))).geom as geom
                                  FROM %1%.planet_osm_ways w_inner WHERE w_inner.id IN(%4%)) AS foo
                          ) -- array
                        ) -- mk poly
                        FROM %1%.planet_osm_ways w WHERE w.id IN (%3%))
                        )sql") % schema % relation->id % outer_id_sql %
                                                            inner_id_sql));
                    }
                }
            }

            if (!multi_polygons_parts_sql.empty()) {
                std::string insert_sql;
                // Single or multi?
                if (polygons.size() > 1) {
                    insert_sql = str(format(R"sql(
               INSERT INTO %1%.planet_osm_polygon (osm_id, way, tags %3% )
                   VALUES (-%2%, ST_Collect(ARRAY[%6%]), %5% %4%)
               )sql") % schema % relation->id %
                                     parser.tag_field_names % parser.tag_field_values % parser.tags_hstore_literal %
                                     multi_polygons_parts_sql);
                } else {
                    insert_sql = str(format(R"sql(
               INSERT INTO %1%.planet_osm_polygon (osm_id, way, tags %3% )
                   VALUES (-%2%, %6%, %5% %4%)
               )sql") % schema % relation->id %
                                     parser.tag_field_names % parser.tag_field_values % parser.tags_hstore_literal %
                                     multi_polygons_parts_sql);
                }

                //std::cerr << insert_sql << std::endl;

                worker.exec0(insert_sql);

                // Update area
                const auto update_sql = str(format(R"sql(
                 UPDATE %1%.planet_osm_polygon SET
                   way_area = ST_Area(way)
                 WHERE osm_id = -%2%)sql") %
                                            schema % relation->id);
                worker.exec0(update_sql);
                //std::cerr << update_sql << std::endl;
            }
        }

        worker.exec("COMMIT;");
    } catch (const std::exception &ex) {
        log_error(_("Couldn't upsert polygon records: %1%"), ex.what());
        worker.exec("ROLLBACK;");
        return false;
    }
    return true;
}

bool
Osm2Pgsql::removeWay(const std::shared_ptr<osmobjects::OsmWay> &way) const
{
    // Preconditions
    assert(static_cast<bool>(sdb));

    // delete from middle table
    const std::string middle_sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_ways WHERE id = $1
  )sql") % schema)};

    // Delete from roads
    const std::string roads_sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_roads WHERE osm_id = $1
  )sql") % schema)};

    // Delete from lines
    const std::string line_sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_line WHERE osm_id = $1
  )sql") % schema)};

    // Delete from polygons
    const std::string polygon_sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_polygon WHERE osm_id = $1
  )sql") % schema)};

    try {
        pqxx::work worker(*sdb);
        worker.exec_params0(middle_sql, way->id);
        worker.exec_params0(roads_sql, way->id);
        worker.exec_params0(line_sql, way->id);
        worker.exec_params0(polygon_sql, way->id);
        worker.commit();
    } catch (const std::exception &ex) {
        log_error(_("Couldn't remove way record: %1%"), ex.what());
        return false;
    }
    return true;
}

bool
Osm2Pgsql::removeNode(const std::shared_ptr<osmobjects::OsmNode> &node) const
{
    // Preconditions
    assert(static_cast<bool>(sdb));

    // delete from middle nodes table
    const std::string middle_sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_nodes WHERE id = $1
  )sql") % schema)};
    // delete from point table
    const std::string sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_point WHERE osm_id = $1
  )sql") % schema)};
    try {
        pqxx::work worker(*sdb);
        worker.exec_params0(middle_sql, node->id);
        worker.exec_params0(sql, node->id);
        worker.commit();
    } catch (const std::exception &ex) {
        log_error(_("Couldn't remove node record: %1%"), ex.what());
        return false;
    }
    return true;
}

bool
Osm2Pgsql::removeRelation(const std::shared_ptr<osmobjects::OsmRelation> &relation) const
{
    // Preconditions
    assert(static_cast<bool>(sdb));

    // delete from middle table
    const std::string middle_sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_rels WHERE id = $1
  )sql") % schema)};

    // Delete from multi polygons
    const std::string polygon_sql{str(format(R"sql(
  DELETE FROM %1%.planet_osm_polygon WHERE osm_id = -%2%
  )sql") % schema % relation->id)};

    try {
        pqxx::work worker(*sdb);
        worker.exec_params0(middle_sql, relation->id);
        worker.exec0(polygon_sql);
        worker.commit();
    } catch (const std::exception &ex) {
        log_error(_("Couldn't remove relation record: %1%"), ex.what());
        return false;
    }
    return true;
}

bool
Osm2Pgsql::connect(const std::string &_dburl)
{
    const bool result{pq::Pq::connect(_dburl)};
    if (result) {
        dburl = _dburl;
    } else {
        dburl.clear();
    }
    return result;
}

bool
Osm2Pgsql::getLastUpdateFromDb()
{
    if (isOpen()) {
        const std::string sql{str(format(R"sql(
        SELECT MAX(foo.ts) AS ts FROM(
          SELECT MAX(tags -> 'osm_timestamp') AS ts FROM %1%.planet_osm_point
          UNION
          SELECT MAX(tags -> 'osm_timestamp') AS ts FROM %1%.planet_osm_line
          UNION
          SELECT MAX(tags -> 'osm_timestamp') AS ts FROM %1%.planet_osm_polygon
          UNION
          SELECT MAX(tags -> 'osm_timestamp') AS ts FROM %1%.planet_osm_roads
        ) AS foo
      )sql") % schema)};
        try {
            const auto result{query(sql)};
            const auto row{result.at(0)};
            if (row.size() != 1) {
                return false;
            }
            auto timestamp{row[0].as<std::string>()};
            timestamp[10] = ' '; // Drop the 'T' in the middle
            timestamp.erase(19); // Drop the final 'Z'
            last_update = time_from_string(timestamp);
            return last_update != not_a_date_time;
        } catch (std::exception const &e) {
            log_error(_("Error getting last update from osm2pgsql DB: %1%"), e.what());
        }
        return false;
    } else {
        return false;
    }
}

std::map<long, std::pair<long, long>>
Osm2Pgsql::notClosedWays(const std::list<long> line_ids, pqxx::nontransaction &worker) const
{

    std::map<long, std::pair<long, long>> result;
    if (!line_ids.empty()) {

        std::list<std::string> line_str_ids;
        for (const auto &id: std::as_const(line_ids)) {
            line_str_ids.push_back(std::to_string(id));
        }

        const auto sql{str(format(R"sql(
       SELECT id, nodes[1] node_a, nodes[CARDINALITY(nodes)] node_b FROM %1%.planet_osm_ways
         WHERE id IN (%2%) AND nodes[1] != nodes[CARDINALITY(nodes)])sql") %
                           schema % boost::algorithm::join(line_str_ids, ", "))};

        const auto ways{worker.exec(sql)};

        for (const auto &way: std::as_const(ways)) {
            result[way["id"].as(long())] = std::make_pair<long, long>(way["node_a"].as(long()), way["node_b"].as(long()));
        }
    }
    return result;
}

const std::string &
Osm2Pgsql::getSchema() const
{
    return schema;
}

void
Osm2Pgsql::setSchema(const std::string &newSchema)
{
    schema = newSchema;
}

void
Osm2Pgsql::TagParser::parse(const std::map<std::string, std::string> &tags, const pqxx::nontransaction &worker, bool is_point)
{

    for (const auto &tag: tags) {
        if (z_index_map.find(tag) != z_index_map.cend()) {
            is_road = z_index_map.at(tag).second;
            z_order += z_index_map.at(tag).first;
        }
        if (!tag.second.empty()) {
            if (generic_keys.find(tag.first) != generic_keys.cend()) {
                has_generic_key = true;
            }
            if (polygon_tags.find(tag.first) != polygon_tags.cend() || (tag.first == "area" && tag.second == "yes")) {
                is_polygon = true;
            }
            if (tags_array_literal.size() > 3) {
                tags_array_literal.append(",");
            }
            // Array literal needs backslash before double quotes
            const auto tag_value{worker.esc(tag.second)};
            const auto tag_name{worker.esc(tag.first)};
            const auto tag_name_safe{std::regex_replace(tag_name, tags_escape_re, R"raw(\\$1)raw")};
            const auto tag_value_safe{std::regex_replace(tag_value, tags_escape_re, R"raw(\\$1)raw")};
            tags_array_literal.append('"' + tag_name_safe + "\",\"" + tag_value_safe + '"');

            // z order
            if (tag.first == "layer") {
                try {
                    z_order += std::stoi(tag.second) * 10;
                } catch (const std::exception &ex) {
                    log_error(_("Error converting layer to integer: %1%"), ex.what());
                }
            }

            // Tags stored into columns
            if ((column_stored_tags.find(tag.first) != column_stored_tags.cend()) ||
                (is_point && column_points_stored_tags.find(tag.first) != column_points_stored_tags.cend())) {
                tag_field_names.append(separator + worker.quote_name(tag.first));
                const auto value{"E'" + worker.esc(tag.second) + "'"};
                tag_field_values.append(separator + value);
                tag_field_updates.append(separator + worker.quote_name(tag.first) + " = " + value);
            } else { // Tags added to "tags"
                tags_hstore_literal.append((tags_hstore_literal.size() > 3 ? ", \"" : "\"") + tag_name_safe + "\" => \"" +
                                           tag_value_safe + '"');
            }
        }
    }
    tags_array_literal.append("}'");
    tags_hstore_literal.append("'");
}

} // namespace osm2pgsql

// local Variables:
// mode: C++
// indent-tabs-mode: t
// End:
