//
// Copyright (c) 2020, 2021, 2022 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <array>
#include <cassert>
#include <chrono>
#include <cstdlib>
#include <deque>
#include <iostream>
#include <list>
#include <memory>
#include <pqxx/pqxx>
#include <sstream>
#include <string>
#include <thread>
#include <tuple>
#include <vector>
#include <thread>

#include "boost/date_time/posix_time/posix_time.hpp"
#include <boost/date_time.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;
#include <boost/filesystem.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/device/array.hpp>
#include <boost/iostreams/device/back_inserter.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/program_options.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/regex.hpp>
#include <boost/timer/timer.hpp>

using namespace boost;
namespace opts = boost::program_options;

// #include "hotosm.hh"
#include "data/geoutil.hh"
#include "galaxy/changeset.hh"
#include "galaxy/osmchange.hh"
// #include "galaxy/replication.hh"
#include "data/import.hh"
#include "data/threads.hh"
#include "data/underpass.hh"
#include "log.hh"
#include "replicatorconfig.hh"

using namespace galaxy;
using namespace underpass;
using namespace replicatorconfig;

#define BOOST_BIND_GLOBAL_PLACEHOLDERS 1

// Exit code when connection to DB fails
#define EXIT_DB_FAILURE -1

using namespace logger;

// Forward declarations
namespace changeset {
class ChangeSet;
};

/// A helper function to simplify the main part.
template <class T> std::ostream &
operator<<(std::ostream &os, const std::vector<T> &v)
{
    copy(v.begin(), v.end(), std::ostream_iterator<T>(os, " "));
    return os;
}

/// \class Replicator
/// \brief This class does all the actual work
///
/// This class identifies, downloads, and processes a replication file.
/// Replication files are available from the OSM planet server.
class Replicator : public replication::Planet {
  public:
    /// Create a new instance, and read in the geoboundaries file.
    Replicator(void) {
        auto hashes = std::make_shared<std::map<std::string, int>>();
        // These initialize default for finding replication files
        //ptime time0 = time_from_string("2012-09-12 09:26:06 ");
        //StateFile state0("/000/000/000", 1000000, time0, replication::minutely);
        //default_minutes.push_back(state0);

        ptime time1 = time_from_string("2014-08-12 06:02:02");
        StateFile state1("/001/000/000", 1000000, time1, replication::minutely);
        default_minutes.push_back(state1);

        ptime time2 = time_from_string("2016-07-08 21:53:00");
        StateFile state2("/002/000/000", 2000000, time2, replication::minutely);
        default_minutes.push_back(state2);

        ptime time3 = time_from_string("2018-06-04 06:45:02");
        StateFile state3("/003/000/000", 3000000, time3, replication::minutely);
        default_minutes.push_back(state3);

        ptime time4 = time_from_string("2020-04-30 06:41:02");
        StateFile state4("/004/000/000", 3000000, time4, replication::minutely);
        default_minutes.push_back(state4);

        // Changesets
        ptime time9 = time_from_string("2012-10-28 19:36:01");
        StateFile state9("/000/000/000", 3000000, time9, replication::changeset);
        default_changesets.push_back(state9);

        ptime time8 = time_from_string("2014-10-07 07:58:01");
        StateFile state8("/001/000/000", 3000000, time8, replication::changeset);
        default_changesets.push_back(state8);

        ptime time7 = time_from_string("2016-08-01 20:43:01");
        StateFile state7("/002/000/000", 3000000, time7, replication::changeset);
        default_changesets.push_back(state7);

        ptime time6 = time_from_string("2018-07-29 16:33:01");
        StateFile state6("/003/000/000", 3000000, time6, replication::changeset);
        default_changesets.push_back(state6);

        ptime time5 = time_from_string("2020-06-28 23:26:01");
        StateFile state5("/004/000/000", 3000000, time5, replication::changeset);
        default_changesets.push_back(state5);
    };

    /// Initialize the raw_user, raw_hashtags, and raw_changeset tables
    /// in the OSM stats database from a changeset file
    bool initializeRaw(std::vector<std::string> &rawfile, const std::string &database)
    {
        for (auto it = std::begin(rawfile); it != std::end(rawfile); ++it) {
            changes->importChanges(*it);
        }
        // FIXME: return a real value
        return false;
    };

    std::shared_ptr<RemoteURL> findRemotePath(const replicatorconfig::ReplicatorConfig &config, ptime time) {
        std::vector<StateFile> default_states;
        std::string suffix;
        std::string fullurl;

        if (config.frequency == replication::minutely) {
            default_states = default_minutes;
            suffix = ".state.txt";
        } else {
            suffix = ".osm.gz";
            default_states = default_changesets;
        }
        connectServer("https://planet.maps.mail.ru");
        auto remote = std::make_shared<RemoteURL>();
        ptime now = boost::posix_time::microsec_clock::universal_time();

        boost::format majorfmt("%03d");
        boost::format minorfmt("%03d");
        boost::format indexfmt("%03d");
        int major=0, minor=0, index=0, span=0;
        int currentdiff=0, lowerdiff=0, upperdiff=0, drift=0;
        ptime timestamp;
        int i = default_states.size() - 1;
        while (i >= 0) {
            time_duration delta = default_states[i].timestamp - time;
            if ((delta.hours()*60) + delta.minutes() < 0) {
                delta = now - time;
            }
            currentdiff =  (delta.hours()*60) + delta.minutes();

            delta = time - default_states[i].timestamp;
            upperdiff =  (delta.hours()*60) + delta.minutes();

            delta = time - default_states[i-1].timestamp;
            lowerdiff =  (delta.hours()*60) + delta.minutes();

            delta = default_states[i].timestamp - default_states[i-1].timestamp;
            span =  ((delta.hours()*60) + delta.minutes());
            drift = span/1000;
            // int drift =  ((delta.hours()*60) + delta.minutes()) / 1000;
            if (drift < 0) {
                delta = default_states[i].timestamp - time;
            }
            // std::cerr << "Times: " << i << ": " << currentdiff << ", " << lowerdiff  << ", " << upperdiff << ", " << drift << ", " << to_simple_string( default_states[i].timestamp) << std::endl;
            // It's in this sub directory
            if (currentdiff < span && upperdiff > 0) {
                major = default_states[i].getMajor();
                // go back a few directories
                minor = (upperdiff/drift) * 0.96;
                break;
            } else if (upperdiff > 0) {
                delta = default_states[i].timestamp - time;
                major = default_states[i].getMajor() + 1;
                minor = abs((drift*lowerdiff)/933)/1000;
                default_states[i].dump();
                break;
            } else if (upperdiff < 0) {
                major = default_states[i-1].getMajor();
                if (currentdiff > span) {
                    int j = default_states.size();
                    while (j <= 0) {
                        if (((currentdiff - span*j) * j)>span*j) {
                            major = j;
                            break;
                        }
                        j--;
                    }
                    int diff = abs(lowerdiff) - span;
                    if (diff < 0) {
                        major--;
                        minor = (span - abs(lowerdiff))/drift;
                    } else {
                        minor = span - diff;
                        minor = (minor/drift) * 0.96;
                    }
                    if (minor < 0) {
                        major--;
                        minor = drift-abs(minor) * 1.06;
                    }
                } else {
                    minor = (lowerdiff/drift) * 0.96;
                }
                break;
            }
            i--;
        }

        majorfmt % (major);
        minorfmt % (minor);
        index = 0;
        indexfmt % (index);
        std::string path = majorfmt.str() + "/" + minorfmt.str() + "/" + indexfmt.str();
        std::string cached = config.datadir + StateFile::freq_to_string(config.frequency);
        cached += "/" + path + suffix;
        fullurl = "https://planet.maps.mail.ru/" + cached;
        remote->parse(fullurl);
        if (config.frequency != replication::changeset) {
            if (!boost::filesystem::exists(cached)) {
                // remote->dump();
                auto data = downloadFile(*remote);
                // remote file doesn't exist, this is a 'Bad Request HTTP response
                while (data->size() == 0) {
                    if (minor > drift) {
                        major++;
                        minor -= drift;
                    }
                    remote->updatePath(major, minor, 0);
                    remote->dump();
                    data = downloadFile(*remote);
                    if (data->size() == 0) {
                        minor--;
                    }
                }
            }
            StateFile start(remote->filespec, false);
            start.dump();
            if (start.timestamp == not_a_date_time) {
                // break;
            }
            // state.txt files aren't compressed
            timestamp = start.timestamp;
        } else {
            changeset::ChangeSetFile change;
            remote->updatePath(major, minor, index);
            remote->dump();
            if (boost::filesystem::exists(remote->filespec)) {
                change.readChanges(remote->filespec);
            } else {
                auto data = downloadFile(*remote);
                auto xml = processData(remote->filespec, *data);
                std::istream& input(xml);
                change.readXML(input);
            }
            change.dump();
            timestamp = change.changes.back()->created_at;
        }

        remote->dump();
        time_duration delta4 = time - timestamp;
        index = abs((delta4.hours()*60) + delta4.minutes());
        if (index > drift) {
            int diff = index/1000;
            minor += diff;
            index -= (index/1000)*1000;
        }
        // std::cerr << "Timestamp: " << to_simple_string(timestamp) << std::endl;
        // std::cerr << "Time: " << to_simple_string(time) << std::endl;
        // std::cerr << "Major: " << major << std::endl;
        minor -= 1;
        // std::cerr << "Minor: " << minor << std::endl;
        // std::cerr << "Index: " << index << std::endl;
        if (minor > 1000) {
            minor -= 1000;
        }

        boost::format newfmt("%03d");
        if (index > 1000) {
            newfmt % ((minor)/1000);
            index -= 1000;
        } else {
            newfmt = minorfmt;
        }
        indexfmt % (index);
        // path = majorfmt.str() + "/" + newfmt.str() + "/" + indexfmt.str();
        // std::cerr << "Path: " << path << std::endl;
        remote->updatePath(major, minor, index);

        if (suffix == ".state.txt") {
            std::size_t pos = remote->filespec.find(suffix);
            remote->filespec = remote->filespec.replace(pos, suffix.size(), ".osc.gz");
        }

        return remote;
    };

    // These are used for the import command
private:
    std::vector<StateFile> default_minutes;
    std::vector<StateFile> default_changesets;
    std::shared_ptr<changeset::ChangeSetFile> changes;  ///< All the changes in the file
    std::shared_ptr<std::map<std::string, int>> hashes; ///< Existing hashtags
};

int
main(int argc, char *argv[])
{

    // Store the file names for replication files
    std::string changeset;
    std::string osmchange;

    // The changesets URL path (e.g. "/001/001/999")
    std::string starting_url_path;

    std::string datadir = "replication/";
    std::string boundary = "priority.geojson";

    ReplicatorConfig config;

    opts::positional_options_description p;
    opts::variables_map vm;
    try {
        opts::options_description desc("Allowed options");
        // clang-format off
        desc.add_options()
            ("help,h", "display help")
            ("server,s", opts::value<std::string>(), "Database server for replicator output (defaults to localhost/galaxy) "
                                                     "can be a hostname or a full connection string USER:PASSSWORD@HOST/DATABASENAME")
            ("tmserver", opts::value<std::string>(), "Tasking Manager database server for input  (defaults to localhost/taskingmanager), "
                                                     "can be a hostname or a full connection string USER:PASSSWORD@HOST/DATABASENAME")
            ("osm2pgsqlserver", opts::value<std::string>(), "Osm2pgsql database server (defaults to an empty string), "
                                                     "can be a hostname or a full connection string USER:PASSSWORD@HOST/DATABASENAME")
            ("tmusersfrequency", opts::value<std::string>(), "Frequency in seconds for the Tasking Manager database users "
                                                             "synchronization: -1 (disabled), 0 (single shot), > 0 (interval in seconds)")
            ("planet,p", opts::value<std::string>(), "Replication server (defaults to planet.maps.mail.ru)")
            ("url,u", opts::value<std::string>(), "Starting URL path (ex. 000/075/000), takes precedence over 'timestamp' option")
            ("monitor,m", "Start monitoring")
            ("frequency,f", opts::value<std::string>(), "Update frequency (hourly, daily), default minutely)")
            ("timestamp,t", opts::value<std::vector<std::string>>(), "Starting timestamp (can be used 2 times to set a range)")
            ("import,i", opts::value<std::string>(), "Initialize OSM database with datafile")
            ("boundary,b", opts::value<std::string>(), "Boundary polygon file name")
            ("datadir", opts::value<std::string>(), "Base directory for cached files (with ending slash)")
            ("verbose,v", "Enable verbosity")
            ("logstdout,l", "Enable logging to stdout, default is log to underpass.log")
            ("changefile", opts::value<std::string>(), "Import change file")
            ("concurrency,c", opts::value<std::string>(), "Concurrency")
            ("debug,d", "Enable debug messages for developers");
        // clang-format on

        opts::store(opts::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
        opts::notify(vm);

        if (vm.count("help")) {
            std::cout << "Usage: options_description [options]" << std::endl;
            std::cout << desc << std::endl;
            std::cout << "A few configuration options can be set through the "
                         "environment,"
                      << std::endl;
            std::cout << "this is the current status of the configuration "
                         "options with"
                      << std::endl;
            std::cout << "the environment variable names and their current "
                         "values (possibly defaults)."
                      << std::endl;
            std::cout << config.dbConfigHelp() << std::endl;
            return 0;
        }
    } catch (std::exception &e) {
        std::cout << e.what() << std::endl;
        return 1;
    }

    logger::LogFile &dbglogfile = logger::LogFile::getDefaultInstance();
    if (vm.count("verbose")) {
        dbglogfile.setVerbosity();
    }

    if (!vm.count("logstdout")) {
        dbglogfile.setWriteDisk(true);
        dbglogfile.setLogFilename("underpass.log");
    }

    if (vm.count("debug")) {
        dbglogfile.setVerbosity();
    }

    // Osm2pgsql options
    if (vm.count("osm2pgsqlserver")) {
        config.osm2pgsql_db_url = vm["osm2pgsqlserver"].as<std::string>();
    }

    // Planet server
    if (vm.count("planet")) {
        config.planet_server = vm["planet"].as<std::string>();
        // Strip https://
        if (config.planet_server.find("https://") == 0) {
            config.planet_server = config.planet_server.substr(8);
        }

        if (boost::algorithm::ends_with(config.planet_server, "/")) {
            config.planet_server.resize(config.planet_server.size() - 1);
        }
    }

    // TM users options
    if (vm.count("tmserver")) {
        config.taskingmanager_db_url = vm["tmserver"].as<std::string>();
    }

    if (vm.count("concurrency")) {
        const auto concurrency = vm["concurrency"].as<std::string>();
        try {
            // Set minimum required because we are starting separate threads for monitoring anyway
            config.concurrency = std::max(3, std::stoi(concurrency));
            log_debug(_("Hardware threads: %1%"), std::thread::hardware_concurrency());
            if (config.concurrency > std::thread::hardware_concurrency()) {
                log_error("ERROR: concurrency cannot exceed the number of threads supported by hardware (%1%)!", std::thread::hardware_concurrency());
            }
        } catch (const std::exception &) {
            log_error("ERROR: error parsing \"concurrency\"!");
            exit(-1);
        }
    } else {
        config.concurrency = std::thread::hardware_concurrency();
    }

    if (vm.count("tmusersfrequency")) {
        const auto freqValue{vm["tmusersfrequency"].as<std::string>()};
        char *p;
        const long converted = strtol(freqValue.c_str(), &p, 10);
        if (*p) {
            log_error("ERROR: You need to supply a valid integer for "
                      "tmusersfrequency!");
            exit(-1);
        } else {
            config.taskingmanager_users_update_frequency = converted;
        }
    }

    if (vm.count("boundary")) {
        boundary = vm["boundary"].as<std::string>();
    }

    if (vm.count("server")) {
        config.galaxy_db_url = vm["server"].as<std::string>();
    }

    geoutil::GeoUtil geou;
    if (!geou.readFile(boundary)) {
        log_debug(_("Could not find '%1%' area file!"), boundary);
    }

    // Tasking Manager users sync setup

    // Thread safe flag to exit the periodic sync loop
    std::atomic<bool> tmUserSyncIsActive{true};

    // RIIA Custom deleter because of multiple exit points
    auto stopTmUserSyncMonitor = [&tmUserSyncIsActive](std::thread *ptr) {
        if (ptr->joinable() && tmUserSyncIsActive) {
            tmUserSyncIsActive = false;
            ptr->join();
        }
        delete ptr;
    };

    std::unique_ptr<std::thread, decltype(stopTmUserSyncMonitor)> tmUserSyncMonitorThread(nullptr, stopTmUserSyncMonitor);
    if (config.taskingmanager_users_update_frequency >= 0) {
        tmUserSyncMonitorThread.reset(new std::thread(threads::threadTMUsersSync, std::ref(tmUserSyncIsActive), config));
    }

    // End of Tasking Manager user sync setup

    Replicator replicator;
    if (vm.count("changefile")) {
        std::string file = vm["changefile"].as<std::string>();
        std::cout << "Importing change file " << file << std::endl;
        auto changeset = std::make_shared<changeset::ChangeSetFile>();
        changeset->readChanges(file);
        changeset->areaFilter(geou.boundary);
        galaxy::QueryGalaxy ostats;
        if (ostats.connect(config.galaxy_db_url)) {
            for (auto it = std::begin(changeset->changes); it != std::end(changeset->changes); ++it) {
                ostats.applyChange(*it->get());
            }
        } else {
            log_error("ERROR: could not connect to galaxy DB, check 'server' "
                      "parameter!");
            exit(-1);
        }

        exit(0);
    }

    std::vector<std::string> rawfile;
    std::shared_ptr<std::vector<unsigned char>> data;

    if (!starting_url_path.empty() && vm.count("timestamp")) {
        log_debug("ERROR: 'url' takes precedence over 'timestamp' arguments are mutually exclusive!");
        exit(-1);
    }

    // This is the default data directory on that server
    if (vm.count("datadir")) {
        datadir = vm["datadir"].as<std::string>();
    }
    const char *tmp = std::getenv("DATADIR");
    if (tmp != 0) {
        datadir = tmp;
    }

    // Add datadir to config
    config.datadir = datadir;

    if (vm.count("frequency")) {
        const auto strfreq = vm["frequency"].as<std::string>();
        if (strfreq[0] == 'm') {
            config.frequency = replication::minutely;
        } else if (strfreq[0] == 'h') {
            config.frequency = replication::hourly;
        } else if (strfreq[0] == 'd') {
            config.frequency = replication::daily;
        } else {
            log_debug(_("Invalid frequency!"));
            exit(-1);
        }
    }

    if (vm.count("monitor")) {
        auto osmchange = std::make_shared<RemoteURL>();
    // Specify a timestamp used by other options
        if (vm.count("timestamp")) {
            try {
                auto timestamps = vm["timestamp"].as<std::vector<std::string>>();
                if (timestamps[0] == "now") {
                    config.start_time = boost::posix_time::second_clock::universal_time();
                } else {
                    config.start_time = from_iso_extended_string(timestamps[0]);
                    if (timestamps.size() > 1) {
                        config.end_time = from_iso_extended_string(timestamps[1]);
                    }
                }
                osmchange = replicator.findRemotePath(config, config.start_time);
            } catch (const std::exception &ex) {
                log_error("ERROR: could not parse timestamps!");
                exit(-1);
            }
        } else if (vm.count("url")) {
            replicator.connectServer("https://planet.maps.mail.ru");
            // This is the changesets path part (ex. 000/075/000), takes precedence over 'timestamp'
            // option. This only applies to the osm change files, as it's timestamp is used to
            // start the changesets.
            std::string fullurl = "https://planet.maps.mail.ru/replication/" + StateFile::freq_to_string(config.frequency);
            std::vector<std::string> parts;
            boost::split(parts, vm["url"].as<std::string>(), boost::is_any_of("/"));
            // fullurl += "/" + vm["url"].as<std::string>() + "/" + parts[2] + ".state.txt";
            fullurl += "/" + vm["url"].as<std::string>() + ".state.txt";
            osmchange->parse(fullurl);
            auto data = replicator.downloadFile(*osmchange);
            StateFile start(osmchange->filespec, false);
            //start.dump();
            config.start_time = start.timestamp;
            boost::algorithm::replace_all(osmchange->filespec, ".state.txt", ".osc.gz");
        }

        // osmchange->dump();
        std::thread oscthr(threads::startMonitorChanges, std::ref(osmchange),
                           std::ref(geou.boundary), std::ref(config));
        config.frequency = replication::changeset;
        auto changeset = replicator.findRemotePath(config, config.start_time);
        // changeset->dump();

        // Changesets thread
        std::thread osmthr(threads::startMonitorChangesets, std::ref(changeset),
                           std::ref(geou.boundary), std::ref(config));
        log_info(_("Waiting..."));

        oscthr.join();
        osmthr.join();
        exit(0);
    }

    std::string statistics;
    if (vm.count("initialize")) {
        rawfile = vm["initialize"].as<std::vector<std::string>>();
        replicator.initializeRaw(rawfile, statistics);
    }
    std::string osmdb;
    if (vm.count("osm")) {
        osmdb = vm["osm"].as<std::vector<std::string>>()[0];
    }
    if (vm.count("import")) {
        std::string file = vm["import"].as<std::string>();
        import::ImportOSM osm(file, osmdb);
    }

    if (tmUserSyncMonitorThread) {
        if (tmUserSyncMonitorThread->joinable() && tmUserSyncIsActive) {
            tmUserSyncMonitorThread->join();
        }
    }
}

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
